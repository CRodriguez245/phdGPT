<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>phdGPT</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Font family */
        body {
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
        }
        /* Custom scrollbar */
        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: transparent;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #d1d5db;
            border-radius: 3px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #9ca3af;
        }
        /* Active chat history item */
        .chat-history-item.active {
            background-color: #374151;
            color: white;
        }
        .chat-history-item.active:hover {
            background-color: #4b5563;
            color: white;
        }
        /* Active branch item */
        .branch-item.active {
            background-color: #374151;
            color: white;
        }
        .branch-item.active:hover {
            background-color: #4b5563;
            color: white;
        }
        /* List indentation in message bubbles */
        .ai-message-bubble ul,
        .ai-message-bubble ol {
            margin-left: 1.5rem;
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
            padding-left: 1rem;
        }
        .ai-message-bubble li {
            margin-top: 0.25rem;
            margin-bottom: 0.25rem;
            padding-left: 0.25rem;
        }
        .ai-message-bubble ul {
            list-style: none;
            padding-left: 0;
        }
        .ai-message-bubble ol {
            list-style-type: decimal;
            list-style-position: outside;
        }
        .ai-message-bubble ul li {
            position: relative;
            padding-left: 1.5em;
        }
        .ai-message-bubble ul li::before {
            content: "•";
            color: #1f2937;
            position: absolute;
            left: 0;
        }
        /* Handle bullet points in plain text (•) */
        .ai-message-bubble p:has-text("•") {
            padding-left: 1.5rem;
        }
        /* Ensure icon background matches button */
        .branch-icon-wrapper {
            background-color: white;
        }
        .branch-icon-wrapper img {
            background-color: white;
            display: block;
            width: 100%;
            height: 100%;
            object-fit: contain;
            flex-shrink: 0;
        }
        /* Share dropdown */
        .share-dropdown {
            display: none;
            position: absolute;
            top: calc(100% + 8px);
            right: 0;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            min-width: 220px;
            z-index: 50;
        }
        .share-dropdown.show {
            display: block;
        }
        /* Branch dropdown */
        .branch-dropdown {
            display: none;
            position: absolute;
            top: calc(100% + 8px);
            left: 0;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            min-width: 220px;
            z-index: 50;
        }
        .branch-dropdown.show {
            display: block;
        }
        /* Zoom out chat messages when share mode is active */
        #chatMessages {
            transition: transform 0.3s ease;
        }
        body.share-mode #chatMessages {
            transform: scale(0.75);
            transform-origin: top center;
            overflow: visible;
        }
        body.share-mode #chatMessages > div {
            min-height: 133.33%;
        }
        /* Change user message bubbles to blue when Carlos is selected - only for messages after branch point */
        body.carlos-selected #chatMessages .flex.justify-end.branch-message > div.bg-blue-50 {
            background-color: #90DFFB !important;
        }
        /* Change user message bubbles to green when Ted is selected - only for messages after branch point */
        body.ted-selected #chatMessages .flex.justify-end.branch-message:not(.carlos-message) > div.bg-blue-50 {
            background-color: #90FBCD !important;
        }
        /* Change user message bubbles to emerald when Paige is selected - only for messages after branch point */
        body.paige-selected #chatMessages .flex.justify-end.branch-message > div.bg-blue-50 {
            background-color: #10b981 !important;
        }
        /* In Carlos's branch of Sylvia's chat, style Paige's messages (indices 2-3) with emerald */
        /* We'll use a different approach - mark Paige's messages with a class */
        body.sylvia-chat.carlos-selected #chatMessages .flex.justify-end.branch-message.paige-message > div.bg-blue-50 {
            background-color: #10b981 !important;
        }
        /* In Ted's branch of Sylvia's chat, style Carlos's message with blue (#90DFFB) - MUST come before orange rule to override */
        body.sylvia-chat.ted-selected #chatMessages .flex.justify-end.branch-message.carlos-message > div.bg-blue-50 {
            background-color: #90DFFB !important;
        }
        body.sylvia-chat #chatMessages .flex.justify-end.branch-message.carlos-message > div.bg-blue-50 {
            background-color: #90DFFB !important;
        }
        /* Change user message bubbles to orange for Sylvia's shared conversation (only non-branch messages) */
        body.sylvia-chat #chatMessages .flex.justify-end:not(.branch-message):not(.carlos-message) > div.bg-blue-50 {
            background-color: #fb923c !important;
        }
        /* Active branch person styling */
        .branch-person.active {
            background-color: #e5e7eb;
        }
        .branch-person.active > div > div[style*="background-color"] {
            opacity: 0.5;
            filter: brightness(0.6);
        }
        .branch-person.active span {
            font-weight: 600;
            color: #111827;
        }
        .branch-person.active svg {
            color: #111827;
        }
        /* Share tooltip/comment box */
        .share-tooltip-backdrop {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            z-index: 99;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .share-tooltip-backdrop.show {
            display: block;
            opacity: 1;
        }
        .share-tooltip {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            min-width: 400px;
            max-width: 500px;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .share-tooltip.show {
            display: block;
            opacity: 1;
        }
        .share-tooltip-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px;
            border-bottom: 1px solid #e5e7eb;
        }
        .share-tooltip-content {
            padding: 16px;
        }
        /* Share scope radio buttons */
        .share-tooltip-content input[type="radio"] {
            cursor: pointer;
        }
        .share-tooltip-content label {
            user-select: none;
        }
        /* Message selection for sharing */
        .message-selectable {
            position: relative;
            transition: all 0.2s ease;
        }
        /* Only make clickable in share mode */
        body.share-mode .message-selectable {
            cursor: pointer;
        }
        body.share-mode .message-selectable:hover {
            opacity: 0.9;
            transform: scale(1.01);
        }
        /* Selected message styling - unified gray background */
        .message-selectable.selected {
            position: relative;
        }
        .message-selectable.selected::before {
            content: '';
            position: absolute;
            left: -6px;
            right: -6px;
            background-color: #e5e7eb;
            z-index: 0;
        }
        /* First selected message - rounded top, extends down to next selected */
        .message-selectable.selected:first-of-type::before {
            top: -6px;
            bottom: -6px;
            border-radius: 8px 8px 0 0;
        }
        /* Middle selected messages - extends up and down to connect */
        .message-selectable.selected:not(:first-of-type):not(:last-of-type)::before {
            top: -6px;
            bottom: -6px;
        }
        /* Last selected message - rounded bottom, only extends up */
        .message-selectable.selected:last-of-type::before {
            top: -6px;
            bottom: -6px;
            border-radius: 0 0 8px 8px;
        }
        /* Single selected message - all rounded */
        .message-selectable.selected:only-of-type::before {
            border-radius: 8px !important;
        }
        /* Extend to connect consecutive selected messages */
        .message-selectable.selected:not(:last-of-type) + .message-selectable.selected::before {
            top: calc(-1.5rem - 6px);
        }
        .message-selectable.selected:not(:last-of-type)::before {
            bottom: calc(-1.5rem - 6px);
        }
        .message-selectable.selected > div {
            position: relative;
            z-index: 1;
        }
        /* Branch note styling */
        .branch-note {
            position: absolute;
            left: -200px;
            top: 0;
            width: 170px;
            padding: 10px 12px;
            background-color: #f3f4f6;
            border-left: 3px solid #29FFA2; /* Default to Ted's green */
            border-radius: 6px;
            font-size: 11px;
            line-height: 1.5;
            color: #374151;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            z-index: 10;
            margin-left: 16px;
        }
        /* Branch note colors by contributor */
        .branch-note.ted-note {
            border-left-color: #29FFA2;
        }
        .branch-note.paige-note {
            border-left-color: #10b981;
        }
        .branch-note.carlos-note {
            border-left-color: #90DFFB;
        }
        .branch-note.sylvia-note {
            border-left-color: #fb923c;
        }
        .branch-note strong {
            color: #111827;
            font-weight: 600;
            display: block;
            margin-bottom: 4px;
        }
        .message-selectable.selected::after {
            display: none;
        }
        .share-tooltip-content input[type="radio"]:disabled + span {
            color: #9ca3af;
            cursor: not-allowed;
        }
        .share-tooltip-textarea {
            width: 100%;
            min-height: 120px;
            padding: 12px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            resize: vertical;
            font-family: inherit;
            font-size: 14px;
            line-height: 1.5;
            outline: none;
        }
        .share-tooltip-textarea:focus {
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
        }
        .share-tooltip-footer {
            display: flex;
            justify-content: flex-end;
            padding: 12px 16px;
            border-top: 1px solid #e5e7eb;
        }
        .share-tooltip-send {
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 8px 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.2s;
        }
        .share-tooltip-send:hover {
            background: #2563eb;
        }
        .share-tooltip-send-checkmark {
            display: none;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 8px 16px;
            align-items: center;
            justify-content: center;
        }
        .share-tooltip-footer.sent .share-tooltip-send {
            display: none;
        }
        .share-tooltip-footer.sent .share-tooltip-send-checkmark {
            display: flex;
        }
        /* Share button checkmark replacement */
        .share-checkmark {
            display: none;
            padding: 8px 12px;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 9999px;
            color: #10b981;
            cursor: default;
        }
        .share-checkmark.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .share-button-wrapper.hidden .share-button-container {
            display: none;
        }
        .share-button-wrapper.hidden .share-checkmark {
            display: flex;
        }
        /* Notification toast */
        .notification-toast {
            position: fixed;
            top: 80px;
            right: 24px;
            background: white;
            color: #1f2937;
            padding: 16px 20px;
            border-radius: 12px;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            display: none;
            align-items: center;
            gap: 12px;
            opacity: 0;
            transform: translateY(-20px);
            transition: opacity 0.3s ease, transform 0.3s ease;
            border: 1px solid #e5e7eb;
            min-width: 200px;
        }
        .notification-toast.show {
            display: flex;
            opacity: 1;
            transform: translateY(0);
        }
        .notification-toast svg {
            color: #10b981;
            flex-shrink: 0;
        }
        .notification-toast span {
            font-size: 14px;
            font-weight: 500;
            color: #1f2937;
        }
        /* Sent message tooltip */
        .sent-message-tooltip {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            min-width: 400px;
            max-width: 500px;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .sent-message-tooltip.show {
            display: block;
            opacity: 1;
        }
        .sent-message-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px;
            border-bottom: 1px solid #e5e7eb;
        }
        .sent-message-header-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .sent-message-content {
            padding: 16px;
            color: #6b7280;
            line-height: 1.6;
            white-space: pre-wrap;
        }
        .sent-message-checkmark {
            color: #000;
        }
        /* Loading animation */
        @keyframes bounce {
            0%, 100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-4px);
            }
        }
        .animate-bounce {
            animation: bounce 1s infinite;
        }
        /* Disabled input styling */
        input:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        /* Search bar */
        .search-bar {
            display: none;
        }
        .search-bar.show {
            display: block;
        }
    </style>
</head>
<body class="bg-white h-screen overflow-hidden">
    <div class="flex h-screen">
        <!-- Left Sidebar -->
        <aside class="w-64 bg-white border-r border-gray-200 flex flex-col h-full pt-6">
            <!-- Title -->
            <div class="px-4 py-4">
                <h1 class="text-2xl font-medium text-gray-900 pl-3">phdGPT</h1>
            </div>
            <!-- Navigation -->
            <nav class="p-4 space-y-1">
                <button id="newChatButton" class="w-full flex items-center gap-3 px-3 py-2.5 rounded-lg hover:bg-gray-100 transition-colors text-left text-gray-700">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                    </svg>
                    <span class="text-sm font-medium">New chat</span>
                </button>
                <button id="searchChatButton" class="w-full flex items-center gap-3 px-3 py-2.5 rounded-lg hover:bg-gray-100 transition-colors text-left text-gray-700">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                    </svg>
                    <span class="text-sm font-medium">Search chat</span>
                </button>
                <button class="w-full flex items-center gap-3 px-3 py-2.5 rounded-lg hover:bg-gray-100 transition-colors text-left text-gray-700">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" />
                    </svg>
                    <span class="text-sm font-medium">Library</span>
                </button>
            </nav>
            
            <!-- Search Bar -->
            <div id="searchBar" class="search-bar px-4">
                <input 
                    type="text" 
                    id="searchInput"
                    placeholder="Search chats..." 
                    autocomplete="off"
                    class="w-full px-3 py-2 bg-white border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm text-gray-700"
                />
            </div>
            
            <!-- Branches Section -->
            <div class="px-4 pb-4 pt-4">
                <h2 class="text-xs font-semibold text-gray-400 mb-2 tracking-wider px-3">Branches</h2>
                <div id="branchesList" class="space-y-0.5">
                    <button class="branch-item w-full text-left px-3 py-2 rounded-lg hover:bg-gray-200 transition-colors text-sm text-gray-900 truncate" data-chat-id="current-chat">
                        Literature Review Study
                    </button>
                    <button class="branch-item w-full text-left px-3 py-2 rounded-lg hover:bg-gray-200 transition-colors text-sm text-gray-900 truncate" data-chat-id="sylvia-research-questions">
                        Planning a Study on Student Study Habits
                    </button>
                </div>
            </div>
            
            <!-- Chat History -->
            <div class="flex-1 overflow-y-auto custom-scrollbar px-4 pb-4 pt-4">
                <h2 class="text-xs font-semibold text-gray-400 mb-2 tracking-wider px-3">Chats</h2>
                <div id="chatHistoryList" class="space-y-0.5">
                    <button class="chat-history-item w-full text-left px-3 py-2 rounded-lg hover:bg-gray-200 transition-colors text-sm text-gray-900 truncate" data-chat-id="typo-assistance-1">
                        Typo Assistance Request
                    </button>
                    <button class="chat-history-item w-full text-left px-3 py-2 rounded-lg hover:bg-gray-200 transition-colors text-sm text-gray-900 truncate" data-chat-id="generate-images-sora">
                        Generate images on Sora
                    </button>
                    <button class="chat-history-item w-full text-left px-3 py-2 rounded-lg hover:bg-gray-200 transition-colors text-sm text-gray-900 truncate" data-chat-id="urban-green-spaces">
                        Urban Green Spaces
                    </button>
                    <button class="chat-history-item w-full text-left px-3 py-2 rounded-lg hover:bg-gray-200 transition-colors text-sm text-gray-900 truncate" data-chat-id="typo-assistance-2">
                        Typo Assistance Request
                    </button>
                    <button class="chat-history-item w-full text-left px-3 py-2 rounded-lg hover:bg-gray-200 transition-colors text-sm text-gray-900 truncate" data-chat-id="workshop-agenda">
                        Workshop agenda creation
                    </button>
                    <button class="chat-history-item w-full text-left px-3 py-2 rounded-lg hover:bg-gray-200 transition-colors text-sm text-gray-900 truncate" data-chat-id="section-1-structure">
                        Section 1 structure
                    </button>
                </div>
            </div>
            
            <!-- User Profile -->
            <div class="border-t border-gray-200 p-4">
                <div class="flex items-center gap-3">
                    <div class="w-8 h-8 bg-blue-50 rounded-full flex items-center justify-center text-gray-800 font-semibold text-sm">
                        S
                    </div>
                    <div class="flex-1 min-w-0">
                        <p class="text-sm font-medium text-gray-900 truncate">Shruthi Iyer</p>
                        <p class="text-xs text-gray-500 truncate">Student Account</p>
                    </div>
                </div>
            </div>
        </aside>
        
        <!-- Main Content Area -->
        <main class="flex-1 flex flex-col bg-gray-50 h-full overflow-hidden">
            <!-- Header -->
            <header class="flex items-center justify-end px-6 py-4">
                <div class="flex items-center gap-3">
                    <div class="relative">
                        <button id="branchButton" class="flex items-center gap-2 px-3 py-2 bg-white hover:bg-gray-50 rounded-full transition-colors text-gray-700 text-sm font-medium border border-gray-300">
                            <svg class="w-4 h-4 text-gray-700" fill="currentColor" viewBox="0 0 180 238" xmlns="http://www.w3.org/2000/svg">
                                <!-- Left vertical line (from bottom to branch point at ~1/3 from bottom) -->
                                <rect x="40" y="80" width="20" height="120" fill="currentColor"/>
                                <!-- Diagonal branch connecting left to right -->
                                <path d="M50 80 L130 40" stroke="currentColor" stroke-width="20" stroke-linecap="round" stroke-linejoin="round"/>
                                <!-- Right vertical line (from branch connection to arrow base) -->
                                <rect x="120" y="20" width="20" height="40" fill="currentColor"/>
                                <!-- Arrowhead pointing up -->
                                <polygon points="130,20 150,0 170,20 150,20" fill="currentColor"/>
                            </svg>
                            <span>Branch</span>
                        </button>
                        <!-- Branch Dropdown -->
                        <div id="branchDropdown" class="branch-dropdown">
                            <div class="p-4">
                                <input 
                                    type="text" 
                                    placeholder="Search Name" 
                                    class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm mb-3"
                                />
                                <div class="space-y-2">
                                    <div class="branch-person flex items-center gap-3 p-2 hover:bg-gray-50 rounded-lg cursor-pointer justify-between" data-name="Carlos R." data-initial="C" data-color="#90DFFB">
                                        <div class="flex items-center gap-3">
                                            <div class="w-10 h-10 rounded-full flex items-center justify-center text-white font-semibold text-sm" style="background-color: #90DFFB;">
                                                C
                                            </div>
                                            <span class="text-gray-700 text-sm">Carlos R.</span>
                                        </div>
                                        <svg class="w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2">
                                            <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                                            <path stroke-linecap="round" stroke-linejoin="round" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                                        </svg>
                                    </div>
                                    <div class="branch-person flex items-center gap-3 p-2 hover:bg-gray-50 rounded-lg cursor-pointer justify-between" data-name="Paige T." data-initial="P" data-color="#10b981">
                                        <div class="flex items-center gap-3">
                                            <div class="w-10 h-10 rounded-full flex items-center justify-center text-white font-semibold text-sm" style="background-color: #10b981;">
                                                P
                                            </div>
                                            <span class="text-gray-700 text-sm">Paige T.</span>
                                        </div>
                                        <svg class="w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2">
                                            <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                                            <path stroke-linecap="round" stroke-linejoin="round" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                                        </svg>
                                    </div>
                                    <div class="branch-person flex items-center gap-3 p-2 hover:bg-gray-50 rounded-lg cursor-pointer justify-between" data-name="Ted S." data-initial="T" data-color="#29FFA2">
                                        <div class="flex items-center gap-3">
                                            <div class="w-10 h-10 rounded-full flex items-center justify-center text-white font-semibold text-sm" style="background-color: #29FFA2;">
                                                T
                                            </div>
                                            <span class="text-gray-700 text-sm">Ted S.</span>
                                        </div>
                                        <svg class="w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2">
                                            <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                                            <path stroke-linecap="round" stroke-linejoin="round" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                                        </svg>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="relative share-button-wrapper">
                        <div class="share-button-container">
                            <button id="shareButton" class="flex items-center gap-2 px-3 py-2 bg-white hover:bg-gray-50 rounded-full transition-colors text-gray-700 text-sm font-medium border border-gray-300">
                                <div class="branch-icon-wrapper w-4 h-4 bg-white flex items-center justify-center">
                                    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAGVSURBVHgB3VRRTsJAEJ0pmBj9qTcoN0AhwJfuETiCNxBPAJ5Ab2C8gUcof2hC6A3sp58NRiXUdpxpgZSV1i3yIy/ZzGY6M29n+nYB/jsqZYKVUrbtOIevvj8zzbFMAzsd5bx90KTCS/ameUYEjfb5VRjRhLeOrDCmyVlb9UxyseijjGT6HvcRcWMxJLr7OrZuPNcN8moUdjD9hMtF8YDt9dJP6T5g27Nm0IW/oMmjqC9m3mhdkCzZi6/ZUgPYJbIEpjBW0bao6g6RYEh0DzHUWQI2u/zx87C2KZm7eQFRFkHAR3UP+N+MRq6fjbF+FBc5EqhF8WKd4cranNMV+ep3ZI0gJLhNC+NDdIQnfHIcP20+vUC+SUxkYU1y2GUn3ecRAJESE1kwKNK2Do/HEs0hvSvEo80lgHQsnjZHIxJvdSC7iGDnqJaKRvChJEoRFP3wPOgjSuZY5jleIpMT5BMgeGJYav0yJBI755y0Bg7XS2YgD1glTt59G7ZDwHfiNKvCtQ4SPXMAAj6C1upvhfk5d/Xi+4FvVeGhku0AzkwAAAAASUVORK5CYII=" alt="Share" class="w-4 h-4" />
                                </div>
                                <span>Share</span>
                            </button>
                        </div>
                        <div id="shareCheckmark" class="share-checkmark">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2.5">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
                            </svg>
                        </div>
                        <!-- Share Dropdown -->
                        <div id="shareDropdown" class="share-dropdown">
                            <div class="p-4">
                                <input 
                                    type="text" 
                                    placeholder="Search Name" 
                                    class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm mb-3"
                                />
                                <div class="space-y-2">
                                    <div class="share-person flex items-center gap-3 p-2 hover:bg-gray-50 rounded-lg cursor-pointer" data-name="Carlos R." data-initial="C" data-color="#90DFFB">
                                        <div class="w-10 h-10 rounded-full flex items-center justify-center text-white font-semibold text-sm" style="background-color: #90DFFB;">
                                            C
                                        </div>
                                        <span class="text-gray-700 text-sm">Carlos R.</span>
                                    </div>
                                    <div class="share-person flex items-center gap-3 p-2 hover:bg-gray-50 rounded-lg cursor-pointer" data-name="Ted S." data-initial="T" data-color="#29FFA2">
                                        <div class="w-10 h-10 rounded-full flex items-center justify-center text-white font-semibold text-sm" style="background-color: #29FFA2;">
                                            T
                                        </div>
                                        <span class="text-gray-700 text-sm">Ted S.</span>
                                    </div>
                                    <div class="share-person flex items-center gap-3 p-2 hover:bg-gray-50 rounded-lg cursor-pointer" data-name="Paige T." data-initial="P" data-color="#10b981">
                                        <div class="w-10 h-10 rounded-full flex items-center justify-center text-white font-semibold text-sm" style="background-color: #10b981;">
                                            P
                                        </div>
                                        <span class="text-gray-700 text-sm">Paige T.</span>
                                    </div>
                                    <div class="share-person flex items-center gap-3 p-2 hover:bg-gray-50 rounded-lg cursor-pointer" data-name="Sylvia K." data-initial="S" data-color="#f97316">
                                        <div class="w-10 h-10 rounded-full flex items-center justify-center text-white font-semibold text-sm" style="background-color: #f97316;">
                                            S
                                        </div>
                                        <span class="text-gray-700 text-sm">Sylvia K.</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <!-- Share Tooltip Backdrop -->
                    <div id="shareTooltipBackdrop" class="share-tooltip-backdrop"></div>
                    <!-- Sent Message Tooltip -->
                    <div id="sentMessageTooltip" class="sent-message-tooltip">
                        <div class="sent-message-header">
                            <div class="sent-message-header-left">
                                <div id="sentMessageAvatar" class="w-10 h-10 rounded-full flex items-center justify-center text-white font-semibold text-sm">
                                </div>
                                <span id="sentMessageName" class="text-gray-700 font-medium"></span>
                                <svg id="sentMessageCheckmark" class="sent-message-checkmark w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2.5">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
                                </svg>
                            </div>
                            <button id="closeSentMessage" class="text-gray-400 hover:text-gray-600">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                                </svg>
                            </button>
                        </div>
                        <div class="sent-message-content">
                            <p id="sentMessageText"></p>
                        </div>
                    </div>
                    <!-- Share Tooltip -->
                    <div id="shareTooltip" class="share-tooltip">
                        <div class="share-tooltip-header">
                            <div class="flex items-center gap-3">
                                <div id="tooltipAvatar" class="w-10 h-10 rounded-full flex items-center justify-center text-white font-semibold text-sm">
                                </div>
                                <span id="tooltipName" class="text-gray-700 font-medium"></span>
                            </div>
                            <button id="closeTooltip" class="text-gray-400 hover:text-gray-600">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                                </svg>
                            </button>
                        </div>
                        <div class="share-tooltip-content">
                            <div id="selectedMessagesPreview" class="mb-3 p-3 bg-gray-50 rounded-lg text-sm text-gray-600" style="display: none;">
                                <p class="font-medium mb-2">Selected messages:</p>
                                <div id="selectedMessagesList" class="max-h-32 overflow-y-auto"></div>
                            </div>
                            <textarea 
                                id="tooltipTextarea" 
                                class="share-tooltip-textarea" 
                                placeholder="Add a note about what you're sharing..."
                            ></textarea>
                        </div>
                        <div id="shareTooltipFooter" class="share-tooltip-footer">
                            <button id="sendTooltip" type="button" class="share-tooltip-send">
                                <svg class="w-5 h-5 rotate-45" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />
                                </svg>
                                <span>Send</span>
                            </button>
                            <div id="sendTooltipCheckmark" class="share-tooltip-send-checkmark">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2.5">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
                                </svg>
                            </div>
                        </div>
                    </div>
                    <button class="p-2 hover:bg-gray-50 rounded-full transition-colors border border-gray-300">
                        <svg class="w-5 h-5 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2z" />
                        </svg>
                    </button>
                </div>
            </header>
            
            <!-- Chat Messages Area -->
            <div class="flex-1 overflow-y-auto custom-scrollbar py-6" id="chatMessages">
                <div class="max-w-4xl mx-auto px-8">
                    <!-- User Message -->
                    <div class="flex justify-end mb-6 message-selectable">
                        <div class="max-w-[75%] bg-blue-50 rounded-[5px] px-5 py-4 shadow-md">
                            <p class="text-gray-800 leading-relaxed">
                                Hey, I'm designing a study to evaluate how novice researchers use AI tools during literature review. I want to compare three workflows: baseline, AI-summaries, and AI-guided questioning. I'm stuck on how to operationalize "depth of understanding." Any suggestions?
                            </p>
                        </div>
                    </div>
                    
                    <!-- AI Message -->
                    <div class="flex justify-start mb-6 message-selectable">
                        <div class="ai-message-bubble max-w-[75%] bg-white rounded-[5px] px-5 py-4 shadow-md">
                            <div class="text-gray-800 leading-relaxed prose prose-sm max-w-none" id="initialMessage1"></div>
                        </div>
                    </div>
                    
                    <!-- User Message -->
                    <div class="flex justify-end mb-6 message-selectable">
                        <div class="max-w-[75%] bg-blue-50 rounded-[5px] px-5 py-4 shadow-md">
                            <p class="text-gray-800 leading-relaxed">
                                Yes — but I'm worried reviewers will say rubric scoring is subjective. Should I include behavioral metrics?
                            </p>
                        </div>
                    </div>
                    
                    <!-- AI Message -->
                    <div class="flex justify-start mb-6 message-selectable">
                        <div class="ai-message-bubble max-w-[75%] bg-white rounded-[5px] px-5 py-4 shadow-md">
                            <div class="text-gray-800 leading-relaxed prose prose-sm max-w-none" id="initialMessage2"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Input Area -->
            <div>
                <div class="max-w-2xl mx-auto px-6 py-4">
                    <form id="chatForm" class="relative">
                        <textarea 
                            id="messageInput"
                            placeholder="Ask anything" 
                            rows="1"
                            class="w-full bg-blue-500 text-white rounded-full px-5 py-3.5 pr-14 focus:outline-none placeholder-blue-200 text-sm font-medium shadow-md resize-none overflow-hidden leading-tight"
                            style="min-height: 48px; max-height: 200px; line-height: 1.5;"
                        ></textarea>
                        <button 
                            type="submit"
                            class="absolute right-4 flex items-center justify-center text-white hover:text-blue-50 transition-colors p-1.5 pointer-events-auto"
                            style="top: 50%; transform: translateY(-50%);"
                        >
                            <svg class="w-5 h-5 rotate-45" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2.5">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />
                            </svg>
                        </button>
                    </form>
                </div>
            </div>
        </main>
    </div>
    
    <!-- Notification Toast -->
    <div id="notificationToast" class="notification-toast">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2.5">
            <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
        </svg>
        <span>Chat sent</span>
    </div>
    
    <script>
        const chatForm = document.getElementById('chatForm');
        const messageInput = document.getElementById('messageInput');
        
        // Auto-resize textarea and center button
        const sendButton = chatForm.querySelector('button[type="submit"]');
        function autoResizeTextarea() {
            messageInput.style.height = 'auto';
            const newHeight = Math.min(messageInput.scrollHeight, 200);
            messageInput.style.height = newHeight + 'px';
            // Update button position to stay centered
            sendButton.style.top = (newHeight / 2) + 'px';
            sendButton.style.transform = 'translateY(-50%)';
        }
        
        messageInput.addEventListener('input', autoResizeTextarea);
        messageInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                chatForm.dispatchEvent(new Event('submit'));
            } else {
                setTimeout(autoResizeTextarea, 0);
            }
        });
        
        // Initialize button position
        setTimeout(autoResizeTextarea, 0);
        const chatMessages = document.getElementById('chatMessages');
        const branchButton = document.getElementById('branchButton');
        const branchDropdown = document.getElementById('branchDropdown');
        const shareButton = document.getElementById('shareButton');
        const shareDropdown = document.getElementById('shareDropdown');
        const shareTooltip = document.getElementById('shareTooltip');
        const shareTooltipBackdrop = document.getElementById('shareTooltipBackdrop');
        const tooltipAvatar = document.getElementById('tooltipAvatar');
        const tooltipName = document.getElementById('tooltipName');
        const tooltipTextarea = document.getElementById('tooltipTextarea');
        const closeTooltip = document.getElementById('closeTooltip');
        const sendTooltip = document.getElementById('sendTooltip');
        const shareTooltipFooter = document.getElementById('shareTooltipFooter');
        const shareCheckmark = document.getElementById('shareCheckmark');
        const shareButtonWrapper = document.querySelector('.share-button-wrapper');
        const sentMessageTooltip = document.getElementById('sentMessageTooltip');
        const sentMessageAvatar = document.getElementById('sentMessageAvatar');
        const sentMessageName = document.getElementById('sentMessageName');
        const sentMessageText = document.getElementById('sentMessageText');
        const closeSentMessage = document.getElementById('closeSentMessage');
        const notificationToast = document.getElementById('notificationToast');
        const newChatButton = document.getElementById('newChatButton');
        const searchChatButton = document.getElementById('searchChatButton');
        const searchBar = document.getElementById('searchBar');
        const searchInput = document.getElementById('searchInput');
        const chatHistoryList = document.getElementById('chatHistoryList');
        
        // Conversation history to maintain context
        let conversationHistory = [];
        let currentChatId = null;
        let currentBranch = null; // Track current branch (person)
        let branchPoint = null; // Track where the branch started (message index)
        
        // Chat storage functions
        function getChats() {
            const chats = localStorage.getItem('phdgpt_chats');
            return chats ? JSON.parse(chats) : {};
        }
        
        function saveChats(chats) {
            localStorage.setItem('phdgpt_chats', JSON.stringify(chats));
        }
        
        function getChat(chatId) {
            const chats = getChats();
            return chats[chatId] || null;
        }
        
        function saveChat(chatId, chatData) {
            const chats = getChats();
            chats[chatId] = chatData;
            saveChats(chats);
        }
        
        // Initialize sample chats if they don't exist
        function initializeSampleChats() {
            const chats = getChats();
            
            // Sample chat data
            const sampleChats = {
                'typo-assistance-1': {
                    title: 'Typo Assistance Request',
                    messages: [
                        { role: 'user', content: 'Can you help me check for typos in my abstract?' },
                        { role: 'assistant', content: 'I\'d be happy to help you check for typos in your abstract. Please share the text you\'d like me to review.' }
                    ],
                    conversationHistory: [
                        { role: 'user', content: 'Can you help me check for typos in my abstract?' },
                        { role: 'assistant', content: 'I\'d be happy to help you check for typos in your abstract. Please share the text you\'d like me to review.' }
                    ]
                },
                'generate-images-sora': {
                    title: 'Generate images on Sora',
                    messages: [
                        { role: 'user', content: 'How can I generate images using Sora?' },
                        { role: 'assistant', content: 'Sora is OpenAI\'s text-to-video model. For generating images, you might want to use DALL-E or Midjourney instead. However, if you\'re interested in video generation with Sora, I can help explain how that works.' }
                    ],
                    conversationHistory: [
                        { role: 'user', content: 'How can I generate images using Sora?' },
                        { role: 'assistant', content: 'Sora is OpenAI\'s text-to-video model. For generating images, you might want to use DALL-E or Midjourney instead. However, if you\'re interested in video generation with Sora, I can help explain how that works.' }
                    ]
                },
                'urban-green-spaces': {
                    title: 'Urban Green Spaces',
                    messages: [
                        { role: 'user', content: 'What are the benefits of urban green spaces?' },
                        { role: 'assistant', content: 'Urban green spaces provide numerous benefits including improved air quality, reduced urban heat island effects, enhanced mental health, increased biodiversity, and opportunities for recreation and social interaction.' }
                    ],
                    conversationHistory: [
                        { role: 'user', content: 'What are the benefits of urban green spaces?' },
                        { role: 'assistant', content: 'Urban green spaces provide numerous benefits including improved air quality, reduced urban heat island effects, enhanced mental health, increased biodiversity, and opportunities for recreation and social interaction.' }
                    ]
                },
                'typo-assistance-2': {
                    title: 'Typo Assistance Request',
                    messages: [
                        { role: 'user', content: 'I need help proofreading my introduction section.' },
                        { role: 'assistant', content: 'I can help you proofread your introduction. Please share the text, and I\'ll review it for typos, grammar, and clarity.' }
                    ],
                    conversationHistory: [
                        { role: 'user', content: 'I need help proofreading my introduction section.' },
                        { role: 'assistant', content: 'I can help you proofread your introduction. Please share the text, and I\'ll review it for typos, grammar, and clarity.' }
                    ]
                },
                'workshop-agenda': {
                    title: 'Workshop agenda creation',
                    messages: [
                        { role: 'user', content: 'Help me create an agenda for a research workshop.' },
                        { role: 'assistant', content: 'I\'d be happy to help you create a workshop agenda. What is the topic of the workshop, how long will it be, and what are the main objectives?' }
                    ],
                    conversationHistory: [
                        { role: 'user', content: 'Help me create an agenda for a research workshop.' },
                        { role: 'assistant', content: 'I\'d be happy to help you create a workshop agenda. What is the topic of the workshop, how long will it be, and what are the main objectives?' }
                    ]
                },
                'section-1-structure': {
                    title: 'Section 1 structure',
                    messages: [
                        { role: 'user', content: 'How should I structure the first section of my paper?' },
                        { role: 'assistant', content: 'The first section typically serves as an introduction. It should include: 1) Context and background, 2) Problem statement, 3) Research objectives/questions, 4) Paper structure overview. Would you like help with any specific part?' }
                    ],
                    conversationHistory: [
                        { role: 'user', content: 'How should I structure the first section of my paper?' },
                        { role: 'assistant', content: 'The first section typically serves as an introduction. It should include: 1) Context and background, 2) Problem statement, 3) Research objectives/questions, 4) Paper structure overview. Would you like help with any specific part?' }
                    ]
                },
                'sylvia-research-questions': {
                    title: 'Planning a Study on Student Study Habits',
                    messages: [
                        { role: 'user', content: 'Hi! I\'m planning a study about how college students study for exams. I want to understand what study methods work best, but I\'m not sure how to design the study. Can you help me think through this?' },
                        { role: 'assistant', content: 'That\'s a great research topic! To design a good study on student study habits, here are some things to consider:\n\n1. **What do you want to learn?** Are you interested in which study methods students use most? Or which methods help them get better grades?\n2. **Who are you studying?** First-year students? Upperclassmen? Students in specific majors?\n3. **How will you measure success?** Exam scores? Student self-reports? Both?\n4. **What study methods are you comparing?** Flashcards, group study, practice tests, reading notes, etc.?\n\nOnce you decide on these, we can figure out the best way to design your study. What aspect interests you most?' }
                    ],
                    conversationHistory: [
                        { role: 'user', content: 'Hi! I\'m planning a study about how college students study for exams. I want to understand what study methods work best, but I\'m not sure how to design the study. Can you help me think through this?' },
                        { role: 'assistant', content: 'That\'s a great research topic! To design a good study on student study habits, here are some things to consider:\n\n1. **What do you want to learn?** Are you interested in which study methods students use most? Or which methods help them get better grades?\n2. **Who are you studying?** First-year students? Upperclassmen? Students in specific majors?\n3. **How will you measure success?** Exam scores? Student self-reports? Both?\n4. **What study methods are you comparing?** Flashcards, group study, practice tests, reading notes, etc.?\n\nOnce you decide on these, we can figure out the best way to design your study. What aspect interests you most?' }
                    ],
                    branches: {
                        'Paige T.': {
                            name: 'Paige T.',
                            color: '#10b981',
                            conversationHistory: [
                                { role: 'user', content: 'Hi! I\'m planning a study about how college students study for exams. I want to understand what study methods work best, but I\'m not sure how to design the study. Can you help me think through this?' },
                                { role: 'assistant', content: 'That\'s a great research topic! To design a good study on student study habits, here are some things to consider:\n\n1. **What do you want to learn?** Are you interested in which study methods students use most? Or which methods help them get better grades?\n2. **Who are you studying?** First-year students? Upperclassmen? Students in specific majors?\n3. **How will you measure success?** Exam scores? Student self-reports? Both?\n4. **What study methods are you comparing?** Flashcards, group study, practice tests, reading notes, etc.?\n\nOnce you decide on these, we can figure out the best way to design your study. What aspect interests you most?' }
                            ],
                            messages: [
                                { role: 'user', content: 'Hi! I\'m planning a study about how college students study for exams. I want to understand what study methods work best, but I\'m not sure how to design the study. Can you help me think through this?' },
                                { role: 'assistant', content: 'That\'s a great research topic! To design a good study on student study habits, here are some things to consider:\n\n1. **What do you want to learn?** Are you interested in which study methods students use most? Or which methods help them get better grades?\n2. **Who are you studying?** First-year students? Upperclassmen? Students in specific majors?\n3. **How will you measure success?** Exam scores? Student self-reports? Both?\n4. **What study methods are you comparing?** Flashcards, group study, practice tests, reading notes, etc.?\n\nOnce you decide on these, we can figure out the best way to design your study. What aspect interests you most?' },
                                { role: 'user', content: 'I\'m really interested in understanding the student experience - like how they feel about different study methods and why they choose what they do. What kind of study would help me learn about that?' },
                                { role: 'assistant', content: 'That sounds like a perfect fit for a qualitative study! You could:\n\n**Interview students** to hear their stories about studying:\n- "What does your study process look like when preparing for exams?"\n- "How do you decide which study method to use for different classes?"\n- "What makes a study session feel successful to you?"\n\n**Observe students studying** to see what they actually do:\n- Watch how they organize their notes\n- See when they take breaks\n- Notice what helps them focus\n\n**Ask students to keep journals** about their study habits for a few weeks\n\nThese approaches help you understand the "why" and "how" behind study habits, not just the numbers. Would you like help planning interviews or observations?' }
                            ],
                            branchPoint: 2,
                            initialized: true
                        },
                        'Carlos R.': {
                            name: 'Carlos R.',
                            color: '#90DFFB',
                            conversationHistory: [
                                { role: 'user', content: 'Hi! I\'m working on formulating my research questions for my dissertation on educational technology. I want to study how students use AI tools for writing, but I\'m struggling to narrow down my research questions. Any advice?' },
                                { role: 'assistant', content: 'Great topic! For formulating research questions about AI tools in student writing, consider these dimensions:\n\n1. **Scope**: Are you focusing on a specific educational level (K-12, undergraduate, graduate)?\n2. **Outcomes**: What are you measuring? Writing quality, learning outcomes, tool adoption, or something else?\n3. **Context**: Classroom use, homework, or both?\n4. **Comparison**: Are you comparing AI-assisted vs. traditional writing, or different AI tools?\n\nA well-formed research question should be: specific, measurable, achievable, relevant, and time-bound. Would you like to explore any of these dimensions further?' },
                                { role: 'user', content: 'I\'m particularly interested in the qualitative side - understanding students\' experiences and perceptions. How would you frame research questions for a qualitative study on this topic?' },
                                { role: 'assistant', content: 'Excellent! For qualitative research questions, you\'ll want to focus on **experiences, meanings, and processes** rather than causal relationships. Here are some approaches:\n\n**Phenomenological questions**:\n- "What are undergraduate students\' lived experiences when using AI writing tools for academic assignments?"\n- "How do students make sense of AI assistance in their writing process?"\n\n**Case study questions**:\n- "How do students in a specific writing course navigate the use of AI tools throughout a semester?"\n- "What strategies do students develop when integrating AI feedback into their writing?"\n\n**Grounded theory questions**:\n- "What processes do students engage in when deciding whether to use AI tools for different writing tasks?"\n- "How do students negotiate the boundary between AI assistance and their own writing voice?"\n\nQualitative questions often start with "How," "What," or "In what ways" and emphasize depth over breadth. Would you like to refine any of these?' }
                            ],
                            messages: [
                                { role: 'user', content: 'Hi! I\'m working on formulating my research questions for my dissertation on educational technology. I want to study how students use AI tools for writing, but I\'m struggling to narrow down my research questions. Any advice?' },
                                { role: 'assistant', content: 'Great topic! For formulating research questions about AI tools in student writing, consider these dimensions:\n\n1. **Scope**: Are you focusing on a specific educational level (K-12, undergraduate, graduate)?\n2. **Outcomes**: What are you measuring? Writing quality, learning outcomes, tool adoption, or something else?\n3. **Context**: Classroom use, homework, or both?\n4. **Comparison**: Are you comparing AI-assisted vs. traditional writing, or different AI tools?\n\nA well-formed research question should be: specific, measurable, achievable, relevant, and time-bound. Would you like to explore any of these dimensions further?' },
                                { role: 'user', content: 'I\'m particularly interested in the qualitative side - understanding students\' experiences and perceptions. How would you frame research questions for a qualitative study on this topic?' },
                                { role: 'assistant', content: 'Excellent! For qualitative research questions, you\'ll want to focus on **experiences, meanings, and processes** rather than causal relationships. Here are some approaches:\n\n**Phenomenological questions**:\n- "What are undergraduate students\' lived experiences when using AI writing tools for academic assignments?"\n- "How do students make sense of AI assistance in their writing process?"\n\n**Case study questions**:\n- "How do students in a specific writing course navigate the use of AI tools throughout a semester?"\n- "What strategies do students develop when integrating AI feedback into their writing?"\n\n**Grounded theory questions**:\n- "What processes do students engage in when deciding whether to use AI tools for different writing tasks?"\n- "How do students negotiate the boundary between AI assistance and their own writing voice?"\n\nQualitative questions often start with "How," "What," or "In what ways" and emphasize depth over breadth. Would you like to refine any of these?' },
                                { role: 'user', content: 'I\'m leaning toward a quantitative approach. What would good research questions look like for an experimental or quasi-experimental design?' },
                                { role: 'assistant', content: 'For quantitative research, you\'ll want questions that test **relationships, differences, or effects**. Here are some examples:\n\n**Experimental questions**:\n- "Does using AI writing tools improve undergraduate students\' essay quality compared to traditional writing methods?"\n- "What is the effect of AI feedback on students\' writing revision behaviors?"\n\n**Quasi-experimental questions**:\n- "How do writing outcomes differ between students who receive AI-assisted feedback versus peer feedback?"\n- "What is the relationship between frequency of AI tool use and final writing scores?"\n\n**Correlational questions**:\n- "Is there a relationship between students\' self-efficacy and their adoption of AI writing tools?"\n- "How do students\' writing anxiety levels correlate with their use of AI assistance?"\n\nQuantitative questions should specify: **variables** (independent/dependent), **population**, and **context**. They often use language like "Does X affect Y?" or "What is the relationship between X and Y?" Would you like help operationalizing any of these?' }
                            ],
                            branchPoint: 4,
                            initialized: true
                        },
                        'Ted S.': {
                            name: 'Ted S.',
                            color: '#29FFA2',
                            conversationHistory: [
                                { role: 'user', content: 'Hi! I\'m working on formulating my research questions for my dissertation on educational technology. I want to study how students use AI tools for writing, but I\'m struggling to narrow down my research questions. Any advice?' },
                                { role: 'assistant', content: 'Great topic! For formulating research questions about AI tools in student writing, consider these dimensions:\n\n1. **Scope**: Are you focusing on a specific educational level (K-12, undergraduate, graduate)?\n2. **Outcomes**: What are you measuring? Writing quality, learning outcomes, tool adoption, or something else?\n3. **Context**: Classroom use, homework, or both?\n4. **Comparison**: Are you comparing AI-assisted vs. traditional writing, or different AI tools?\n\nA well-formed research question should be: specific, measurable, achievable, relevant, and time-bound. Would you like to explore any of these dimensions further?' },
                                { role: 'user', content: 'I\'m leaning toward a quantitative approach. What would good research questions look like for an experimental or quasi-experimental design?' },
                                { role: 'assistant', content: 'For quantitative research, you\'ll want questions that test **relationships, differences, or effects**. Here are some examples:\n\n**Experimental questions**:\n- "Does using AI writing tools improve undergraduate students\' essay quality compared to traditional writing methods?"\n- "What is the effect of AI feedback on students\' writing revision behaviors?"\n\n**Quasi-experimental questions**:\n- "How do writing outcomes differ between students who receive AI-assisted feedback versus peer feedback?"\n- "What is the relationship between frequency of AI tool use and final writing scores?"\n\n**Correlational questions**:\n- "Is there a relationship between students\' self-efficacy and their adoption of AI writing tools?"\n- "How do students\' writing anxiety levels correlate with their use of AI assistance?"\n\nQuantitative questions should specify: **variables** (independent/dependent), **population**, and **context**. They often use language like "Does X affect Y?" or "What is the relationship between X and Y?" Would you like help operationalizing any of these?' }
                            ],
                            messages: [
                                { role: 'user', content: 'Hi! I\'m working on formulating my research questions for my dissertation on educational technology. I want to study how students use AI tools for writing, but I\'m struggling to narrow down my research questions. Any advice?' },
                                { role: 'assistant', content: 'Great topic! For formulating research questions about AI tools in student writing, consider these dimensions:\n\n1. **Scope**: Are you focusing on a specific educational level (K-12, undergraduate, graduate)?\n2. **Outcomes**: What are you measuring? Writing quality, learning outcomes, tool adoption, or something else?\n3. **Context**: Classroom use, homework, or both?\n4. **Comparison**: Are you comparing AI-assisted vs. traditional writing, or different AI tools?\n\nA well-formed research question should be: specific, measurable, achievable, relevant, and time-bound. Would you like to explore any of these dimensions further?' },
                                { role: 'user', content: 'I\'m leaning toward a quantitative approach. What would good research questions look like for an experimental or quasi-experimental design?' },
                                { role: 'assistant', content: 'For quantitative research, you\'ll want questions that test **relationships, differences, or effects**. Here are some examples:\n\n**Experimental questions**:\n- "Does using AI writing tools improve undergraduate students\' essay quality compared to traditional writing methods?"\n- "What is the effect of AI feedback on students\' writing revision behaviors?"\n\n**Quasi-experimental questions**:\n- "How do writing outcomes differ between students who receive AI-assisted feedback versus peer feedback?"\n- "What is the relationship between frequency of AI tool use and final writing scores?"\n\n**Correlational questions**:\n- "Is there a relationship between students\' self-efficacy and their adoption of AI writing tools?"\n- "How do students\' writing anxiety levels correlate with their use of AI assistance?"\n\nQuantitative questions should specify: **variables** (independent/dependent), **population**, and **context**. They often use language like "Does X affect Y?" or "What is the relationship between X and Y?" Would you like help operationalizing any of these?' }
                            ],
                            branchPoint: 2,
                            initialized: true
                        }
                    },
                    currentBranch: null,
                    branchPoint: null
                }
            };
            
            // Only initialize if chats don't exist
            if (Object.keys(chats).length === 0) {
                saveChats(sampleChats);
            } else {
                // Always ensure the Sylvia chat exists (for the branch)
                if (!chats['sylvia-research-questions']) {
                    chats['sylvia-research-questions'] = sampleChats['sylvia-research-questions'];
                    saveChats(chats);
                }
            }
        }
        
        // Load a chat by ID
        function loadChat(chatId) {
            const chat = getChat(chatId);
            if (!chat) {
                console.error('Chat not found:', chatId);
                return;
            }
            
            currentChatId = chatId;
            currentBranch = chat.currentBranch || null;
            branchPoint = chat.branchPoint || null;
            
            // Load the appropriate conversation history based on branch
            if (currentBranch && chat.branches && chat.branches[currentBranch]) {
                conversationHistory = chat.branches[currentBranch].conversationHistory || [];
            } else {
                conversationHistory = chat.conversationHistory || [];
            }
            
            // Clear current messages
            const messagesContainer = chatMessages.querySelector('.max-w-4xl');
            if (messagesContainer) {
                messagesContainer.innerHTML = '';
            }
            
            // Reset all branch note flags when loading a chat
            tedsBranchNoteAdded = false;
            paigesBranchNoteAdded = false;
            carlosBranchNoteAdded = false;
            sylviasBranchNoteAdded = false;
            
            // Load messages from the appropriate branch
            let messagesToLoad = [];
            let branchPointIndex = null;
            if (currentBranch && chat.branches && chat.branches[currentBranch]) {
                messagesToLoad = chat.branches[currentBranch].messages || [];
                branchPointIndex = chat.branches[currentBranch].branchPoint || null;
            } else {
                messagesToLoad = chat.messages || [];
            }
            
            if (messagesToLoad.length > 0) {
                messagesToLoad.forEach((msg, index) => {
                    // Messages after the branch point should be marked as branch messages
                    // In Carlos's branch of Sylvia's chat, also mark Paige's messages (2-3) as branch messages
                    let isBranchMsg = currentBranch && branchPointIndex !== null && index >= branchPointIndex;
                    if (currentBranch === 'Carlos R.' && currentChatId === 'sylvia-research-questions' && index >= 2 && index < 4) {
                        isBranchMsg = true; // Mark Paige's messages as branch messages too
                    }
                    const messageDiv = addMessageToChat(msg.content, msg.role === 'user', isBranchMsg);
                    // In Carlos's branch, mark Paige's messages (indices 2-3) with a special class for styling
                    if (messageDiv && currentBranch === 'Carlos R.' && currentChatId === 'sylvia-research-questions' && 
                        index >= 2 && index < 4) {
                        messageDiv.classList.add('paige-message');
                    }
                    // In Ted's branch of Sylvia's chat, mark Carlos's message (index 2) with a special class for blue styling
                    if (messageDiv && currentBranch === 'Ted S.' && currentChatId === 'sylvia-research-questions' && 
                        index === 2 && msg.role === 'user' && isBranchMsg) {
                        messageDiv.classList.add('carlos-message');
                        // Force the blue color directly via inline style to ensure it overrides
                        const bubbleDiv = messageDiv.querySelector('div.bg-blue-50');
                        if (bubbleDiv) {
                            bubbleDiv.style.backgroundColor = '#90DFFB';
                        }
                    }
                });
            }
            
            // Clear input and focus
            messageInput.value = '';
            messageInput.style.height = 'auto';
            messageInput.disabled = false;
            messageInput.focus();
            
            // Remove any loading indicators
            removeLoadingIndicator();
            
            // Close any open dropdowns
            branchDropdown.classList.remove('show');
            shareDropdown.classList.remove('show');
            
            // Close any open tooltips
            shareTooltip.classList.remove('show');
            shareTooltipBackdrop.classList.remove('show');
            sentMessageTooltip.classList.remove('show');
            
            // Set UI state based on current branch
            document.body.classList.remove('share-mode', 'carlos-selected', 'ted-selected', 'paige-selected', 'sylvia-chat');
            if (currentBranch === 'Carlos R.') {
                document.body.classList.add('carlos-selected');
            } else if (currentBranch === 'Ted S.') {
                document.body.classList.add('ted-selected');
            } else if (currentBranch === 'Paige T.') {
                document.body.classList.add('paige-selected');
            } else if (chatId === 'sylvia-research-questions' && !currentBranch) {
                // This is Sylvia's shared conversation (main view, not a branch)
                document.body.classList.add('sylvia-chat');
            }
            
            // Update branch person active state
            updateBranchPersonActiveState(currentBranch);
            
            // Update active states for sidebar items
            document.querySelectorAll('.chat-history-item, .branch-item').forEach(item => {
                item.classList.remove('active');
                if (item.dataset.chatId === chatId) {
                    item.classList.add('active');
                }
            });
            
            // Add Sylvia's note if viewing main chat (non-branch view) of Sylvia's conversation
            if (currentChatId === 'sylvia-research-questions' && !currentBranch) {
                setTimeout(() => {
                    addSylviasNote();
                }, 0);
            }
            
            // Scroll to bottom
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        // Save current chat
        function saveCurrentChat() {
            if (!currentChatId) return;
            
            const chat = getChat(currentChatId);
            if (chat) {
                // Initialize branches object if it doesn't exist
                if (!chat.branches) {
                    chat.branches = {};
                }
                
                // CRITICAL: Only update the conversation history for the CURRENT view
                // Never mix branch and main conversation histories
                if (currentBranch && chat.branches && chat.branches[currentBranch]) {
                    // Save to CURRENT branch only - create a deep copy
                    chat.branches[currentBranch].conversationHistory = JSON.parse(JSON.stringify(conversationHistory));
                } else if (!currentBranch) {
                    // Save to main conversation only - create a deep copy
                    chat.conversationHistory = JSON.parse(JSON.stringify(conversationHistory));
                }
                
                // Update messages from DOM
                const messagesContainer = chatMessages.querySelector('.max-w-4xl');
                if (messagesContainer) {
                    const messageDivs = messagesContainer.querySelectorAll('.flex');
                    const messages = [];
                    messageDivs.forEach(div => {
                        // For user messages, get text from p tag
                        // For AI messages, get text from the formatted div (need to extract from HTML)
                        const isUser = div.classList.contains('justify-end');
                        let content = '';
                        
                        if (isUser) {
                            const messageText = div.querySelector('p');
                            if (messageText) {
                                content = messageText.textContent.trim();
                            }
                        } else {
                            // For AI messages, get text from the formatted content div
                            // Try multiple selectors to find the content
                            const messageContent = div.querySelector('.prose') || 
                                                  div.querySelector('.ai-message-bubble > div') ||
                                                  div.querySelector('div > div') ||
                                                  div.querySelector('p');
                            if (messageContent) {
                                // Extract plain text from the formatted HTML
                                content = messageContent.textContent.trim();
                            } else {
                                // Last resort: get all text from the div
                                content = div.textContent.trim();
                            }
                        }
                        
                        if (content) {
                            messages.push({
                                role: isUser ? 'user' : 'assistant',
                                content: content
                            });
                        }
                    });
                    
                    // CRITICAL: Save messages to appropriate location - create a deep copy
                    // IMPORTANT: Only save to the current branch or main, never mix them
                    // The DOM should only contain messages for the current view at this point
                    if (currentBranch && chat.branches && chat.branches[currentBranch]) {
                        // Save to CURRENT branch only - do not touch other branches or main conversation
                        const branchToUpdate = chat.branches[currentBranch];
                        branchToUpdate.messages = JSON.parse(JSON.stringify(messages));
                        // Preserve initialized flag if it exists
                        if (branchToUpdate.initialized === undefined) {
                            branchToUpdate.initialized = false;
                        }
                        // Explicitly ensure we don't modify main conversation when in a branch
                        // chat.messages should remain unchanged
                    } else if (!currentBranch) {
                        // Save to main conversation only - do not touch any branches
                        chat.messages = JSON.parse(JSON.stringify(messages));
                        // Explicitly ensure branches are not modified when in main view
                        // All branch data should remain unchanged
                    }
                }
                
                // Save branch info
                chat.currentBranch = currentBranch;
                chat.branchPoint = branchPoint;
                
                saveChat(currentChatId, chat);
            }
        }
        
        // Function to start a new chat
        function startNewChat() {
            // Save current chat before starting new one
            if (currentChatId) {
                saveCurrentChat();
            }
            
            // Clear conversation history
            conversationHistory = [];
            currentChatId = null;
            currentBranch = null;
            branchPoint = null;
            
            // Clear all chat messages except the container structure
            const messagesContainer = chatMessages.querySelector('.max-w-4xl');
            if (messagesContainer) {
                messagesContainer.innerHTML = '';
            }
            
            // Clear input field
            messageInput.value = '';
            messageInput.style.height = 'auto';
            messageInput.disabled = false;
            messageInput.focus();
            
            // Remove any loading indicators
            removeLoadingIndicator();
            
            // Close any open dropdowns
            branchDropdown.classList.remove('show');
            shareDropdown.classList.remove('show');
            
            // Close any open tooltips
            shareTooltip.classList.remove('show');
            shareTooltipBackdrop.classList.remove('show');
            sentMessageTooltip.classList.remove('show');
            
            // Reset UI states
            document.body.classList.remove('share-mode', 'carlos-selected', 'ted-selected');
            
            // Update branch person active state (none active for new chat)
            updateBranchPersonActiveState(null);
            
            // Scroll to top
            chatMessages.scrollTop = 0;
        }
        
        // New chat button functionality
        newChatButton.addEventListener('click', startNewChat);
        
        // Search chat button functionality
        searchChatButton.addEventListener('click', () => {
            searchBar.classList.toggle('show');
            if (searchBar.classList.contains('show')) {
                searchInput.focus();
            } else {
                searchInput.value = '';
                filterChats('');
            }
        });
        
        // Search input functionality
        searchInput.addEventListener('input', (e) => {
            const query = e.target.value.trim().toLowerCase();
            filterChats(query);
        });
        
        // Close search bar when clicking outside
        document.addEventListener('click', (e) => {
            if (!searchChatButton.contains(e.target) && !searchBar.contains(e.target)) {
                if (searchInput.value.trim() === '') {
                    searchBar.classList.remove('show');
                }
            }
        });
        
        // Function to filter chats based on search query
        function filterChats(query) {
            const chatItems = chatHistoryList.querySelectorAll('.chat-history-item');
            const chats = getChats();
            
            chatItems.forEach(item => {
                const chatId = item.dataset.chatId;
                const chat = chats[chatId];
                
                if (!query) {
                    // Show all chats if no query
                    item.style.display = 'block';
                    return;
                }
                
                // Check if chat title matches query
                const title = chat ? chat.title.toLowerCase() : item.textContent.toLowerCase();
                const matchesTitle = title.includes(query);
                
                // Check if any message content matches query
                let matchesContent = false;
                if (chat && chat.messages) {
                    matchesContent = chat.messages.some(msg => 
                        msg.content.toLowerCase().includes(query)
                    );
                }
                
                // Show if title or content matches
                if (matchesTitle || matchesContent) {
                    item.style.display = 'block';
                } else {
                    item.style.display = 'none';
                }
            });
        }
        
        // Function to render chat history list
        function renderChatHistory() {
            const chats = getChats();
            chatHistoryList.innerHTML = '';
            
            // Sort chats by most recent (you might want to add timestamps)
            const chatEntries = Object.entries(chats);
            
            chatEntries.forEach(([chatId, chat]) => {
                // Exclude 'current-chat' from the Chats section (it belongs in Branches)
                if (chatId === 'current-chat') {
                    return;
                }
                
                // Exclude 'research question formula' chat
                const chatTitle = (chat.title || '').toLowerCase();
                if (chatTitle.includes('research question formula')) {
                    return;
                }
                
                const button = document.createElement('button');
                button.className = 'chat-history-item w-full text-left px-3 py-2 rounded-lg hover:bg-gray-200 transition-colors text-sm text-gray-900 truncate';
                button.dataset.chatId = chatId;
                button.textContent = chat.title || 'Untitled Chat';
                
                button.addEventListener('click', () => {
                    loadChat(chatId);
                });
                
                chatHistoryList.appendChild(button);
            });
        }
        
        // Chat history item click handlers
        document.querySelectorAll('.chat-history-item').forEach(item => {
            item.addEventListener('click', () => {
                const chatId = item.dataset.chatId;
                if (chatId) {
                    loadChat(chatId);
                }
            });
        });
        
        // Branch item click handlers
        document.querySelectorAll('.branch-item').forEach(item => {
            item.addEventListener('click', () => {
                const chatId = item.dataset.chatId;
                if (chatId) {
                    loadChat(chatId);
                }
            });
        });
        
        // Initialize sample chats on page load
        initializeSampleChats();
        
        // Render chat history on page load
        renderChatHistory();
        
        // Initialize current chat from existing HTML messages on page load
        window.addEventListener('DOMContentLoaded', () => {
            // Process initial static messages with markdown
            const initialMsg1 = document.getElementById('initialMessage1');
            const initialMsg2 = document.getElementById('initialMessage2');
            
            if (initialMsg1) {
                const text1 = 'Sure — "depth of understanding" in HCI literature is often operationalized across three dimensions: 1. Breadth (coverage of core ideas, concepts identified) 2. Accuracy (correctness vs hallucination/overgeneralization) 3. Structure (how well connections are made between concepts) You can turn those into a rubric:\n\n• 0-2 points per dimension\n• Evaluate written summaries, outlines, or concept maps\n• Inter-rater reliability check using Cohen\'s k Would you like me to draft the rubric?';
                initialMsg1.innerHTML = markdownToHtml(text1);
            }
            
            if (initialMsg2) {
                const text2 = 'Great instinct. Add process-level indicators, which pair nicely with rubric scoring:\n\n• Time\n• Number of sources consulted\n• Switching behavior (e.g., toggling between article and notes)\n• Latency before taking first note';
                initialMsg2.innerHTML = markdownToHtml(text2);
            }
            
            const messagesContainer = chatMessages.querySelector('.max-w-4xl');
            if (messagesContainer) {
                // Extract messages from existing HTML
                const messageDivs = messagesContainer.querySelectorAll('.flex');
                const existingMessages = [];
                const existingHistory = [];
                
                messageDivs.forEach(div => {
                    // Ensure message-selectable class is present
                    if (!div.classList.contains('message-selectable')) {
                        div.classList.add('message-selectable');
                    }
                    
                    // Add dataset messageId if not present
                    if (!div.dataset.messageId) {
                        div.dataset.messageId = 'msg-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
                    }
                    
                    // Remove any existing click handlers and add new one
                    // (We'll replace the element to remove old listeners, or use a flag to prevent duplicates)
                    const hasClickHandler = div.hasAttribute('data-click-handler-attached');
                    if (!hasClickHandler) {
                        div.setAttribute('data-click-handler-attached', 'true');
                        div.addEventListener('click', (e) => {
                            if (document.body.classList.contains('share-mode')) {
                                e.stopPropagation();
                                e.preventDefault();
                                toggleMessagePair(div);
                                updateSelectedMessages();
                                // Force a reflow to ensure CSS is applied
                                div.offsetHeight;
                            }
                        });
                    }
                    
                    const messageText = div.querySelector('p');
                    if (messageText) {
                        const isUser = div.classList.contains('justify-end');
                        const content = messageText.textContent.trim();
                        if (content) {
                            existingMessages.push({
                                role: isUser ? 'user' : 'assistant',
                                content: content
                            });
                            existingHistory.push({
                                role: isUser ? 'user' : 'assistant',
                                content: content
                            });
                        }
                    }
                });
                
                // If there are existing messages, set up the current chat
                if (existingMessages.length > 0 && !currentChatId) {
                    const initialChatId = 'current-chat';
                    currentChatId = initialChatId;
                    
                    // Use a descriptive title for the landing page chat
                    const title = 'Literature Review Study';
                    
                    const initialChat = {
                        title: title,
                        messages: existingMessages,
                        conversationHistory: existingHistory
                    };
                    
                    // Save to localStorage
                    const chats = getChats();
                    if (!chats[initialChatId]) {
                        saveChat(initialChatId, initialChat);
                    } else {
                        // Update existing chat with current messages
                        chats[initialChatId] = initialChat;
                        saveChats(chats);
                    }
                    
                    // Set active state for the branch item
                    document.querySelectorAll('.branch-item').forEach(item => {
                        item.classList.remove('active');
                        if (item.dataset.chatId === initialChatId) {
                            item.classList.add('active');
                        }
                    });
                    
                    // Set conversation history
                    conversationHistory = existingHistory;
                    
                    // Set active state for the branch item
                    document.querySelectorAll('.branch-item').forEach(item => {
                        item.classList.remove('active');
                        if (item.dataset.chatId === initialChatId) {
                            item.classList.add('active');
                        }
                    });
                }
            }
        });
        
        // Function to convert markdown to HTML
        function markdownToHtml(text) {
            if (!text) return '';
            
            // Helper to escape HTML but preserve already-processed HTML tags
            function escapeText(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
            
            // Helper to process inline formatting in already-escaped text
            function processInlineFormatting(text) {
                // Bold - must not be inside code blocks
                text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                text = text.replace(/__(.*?)__/g, '<strong>$1</strong>');
                // Italic - must not be inside code blocks or bold
                text = text.replace(/(?<!\*)\*(?!\*)([^*]+?)(?<!\*)\*(?!\*)/g, '<em>$1</em>');
                text = text.replace(/(?<!_)_(?!_)([^_]+?)(?<!_)_(?!_)/g, '<em>$1</em>');
                return text;
            }
            
            // Split text preserving code blocks
            const codeBlockRegex = /```([\s\S]*?)```/g;
            const parts = [];
            let lastIndex = 0;
            let match;
            
            while ((match = codeBlockRegex.exec(text)) !== null) {
                if (match.index > lastIndex) {
                    parts.push({ type: 'text', content: text.substring(lastIndex, match.index) });
                }
                parts.push({ type: 'code', content: match[1] });
                lastIndex = match.index + match[0].length;
            }
            if (lastIndex < text.length) {
                parts.push({ type: 'text', content: text.substring(lastIndex) });
            }
            
            if (parts.length === 0) {
                parts.push({ type: 'text', content: text });
            }
            
            // Process each part
            const processedParts = parts.map(part => {
                if (part.type === 'code') {
                    return '<pre class="bg-gray-100 p-3 rounded-lg my-2 overflow-x-auto text-sm"><code>' + escapeText(part.content.trim()) + '</code></pre>';
                } else {
                    // Process text part
                    let content = part.content;
                    
                    // Handle inline code first (before other formatting)
                    content = content.replace(/`([^`\n]+)`/g, function(match, code) {
                        return '<code class="bg-gray-100 px-1.5 py-0.5 rounded text-sm font-mono">' + escapeText(code) + '</code>';
                    });
                    
                    // Split into lines
                    const lines = content.split('\n');
                    const result = [];
                    let inList = false;
                    let listIsOrdered = false;
                    let listItems = [];
                    
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i];
                        let processed = false;
                        
                        // Headers
                        if (line.match(/^### (.*)$/)) {
                            if (inList) {
                                const listTag = listIsOrdered ? '<ol class="ml-6 my-2">' : '<ul class="ml-6 my-2">';
                                const listCloseTag = listIsOrdered ? '</ol>' : '</ul>';
                                result.push(listTag + listItems.join('') + listCloseTag);
                                listItems = [];
                                inList = false;
                            }
                            const headerText = processInlineFormatting(escapeText(line.replace(/^### /, '')));
                            result.push('<h3 class="font-semibold text-lg mt-4 mb-2">' + headerText + '</h3>');
                            processed = true;
                        } else if (line.match(/^## (.*)$/)) {
                            if (inList) {
                                const listTag = listIsOrdered ? '<ol class="ml-6 my-2">' : '<ul class="ml-6 my-2">';
                                const listCloseTag = listIsOrdered ? '</ol>' : '</ul>';
                                result.push(listTag + listItems.join('') + listCloseTag);
                                listItems = [];
                                inList = false;
                            }
                            const headerText = processInlineFormatting(escapeText(line.replace(/^## /, '')));
                            result.push('<h2 class="font-semibold text-xl mt-4 mb-2">' + headerText + '</h2>');
                            processed = true;
                        } else if (line.match(/^# (.*)$/)) {
                            if (inList) {
                                const listTag = listIsOrdered ? '<ol class="ml-6 my-2">' : '<ul class="ml-6 my-2">';
                                const listCloseTag = listIsOrdered ? '</ol>' : '</ul>';
                                result.push(listTag + listItems.join('') + listCloseTag);
                                listItems = [];
                                inList = false;
                            }
                            const headerText = processInlineFormatting(escapeText(line.replace(/^# /, '')));
                            result.push('<h1 class="font-bold text-2xl mt-4 mb-2">' + headerText + '</h1>');
                            processed = true;
                        }
                        // Lists - bullet points on separate lines
                        else if (line.match(/^[\*\-\•] (.*)$/)) {
                            if (!inList) {
                                inList = true;
                                listIsOrdered = false;
                            }
                            let listContent = line.replace(/^[\*\-\•]\s+/, '').trim();
                            // Remove any remaining bullet characters from the content
                            listContent = listContent.replace(/^[\*\-\•]\s+/, '').trim();
                            listContent = processInlineFormatting(escapeText(listContent));
                            listItems.push('<li>' + listContent + '</li>');
                            processed = true;
                        }
                        // Lists - numbered lists
                        else if (line.match(/^\d+\. (.*)$/)) {
                            if (!inList) {
                                inList = true;
                                listIsOrdered = true;
                            }
                            let listContent = line.replace(/^\d+\. /, '');
                            listContent = processInlineFormatting(escapeText(listContent));
                            listItems.push('<li class="ml-4 mb-1">' + listContent + '</li>');
                            processed = true;
                        }
                        // Empty line
                        else if (line.trim() === '') {
                            if (inList) {
                                const listTag = listIsOrdered ? '<ol class="ml-6 my-2">' : '<ul class="ml-6 my-2">';
                                const listCloseTag = listIsOrdered ? '</ol>' : '</ul>';
                                result.push(listTag + listItems.join('') + listCloseTag);
                                listItems = [];
                                inList = false;
                            }
                            if (result.length > 0 && !result[result.length - 1].match(/<\/(p|h1|h2|h3|ul|pre)>$/)) {
                                result.push('</p><p class="mb-2">');
                            }
                            processed = true;
                        }
                        
                        // Regular paragraph text
                        if (!processed) {
                            if (inList) {
                                const listTag = listIsOrdered ? '<ol class="ml-6 my-2">' : '<ul class="ml-6 my-2">';
                                const listCloseTag = listIsOrdered ? '</ol>' : '</ul>';
                                result.push(listTag + listItems.join('') + listCloseTag);
                                listItems = [];
                                inList = false;
                            }
                            let paraContent = processInlineFormatting(escapeText(line));
                            
                            // Handle inline numbered lists (1. 2. 3.) within a paragraph
                            if (line.match(/\d+\.\s+[^•]/) && !line.match(/^\d+\. /)) {
                                // Split by numbered items
                                const parts = line.split(/(?=\d+\.\s+)/);
                                const textParts = [];
                                const numberedItems = [];
                                
                                parts.forEach(part => {
                                    const numberedMatch = part.match(/^(\d+)\.\s+(.+?)(?=\d+\.|$)/);
                                    if (numberedMatch) {
                                        numberedItems.push('<li class="ml-4 mb-1">' + processInlineFormatting(escapeText(numberedMatch[2].trim())) + '</li>');
                                    } else {
                                        const text = part.trim();
                                        if (text && !text.match(/^\d+\./)) {
                                            textParts.push(processInlineFormatting(escapeText(text)));
                                        }
                                    }
                                });
                                
                                if (textParts.length > 0) {
                                    result.push('<p class="mb-2">' + textParts.join(' ') + '</p>');
                                }
                                if (numberedItems.length > 0) {
                                    result.push('<ol class="ml-6 my-2">' + numberedItems.join('') + '</ol>');
                                }
                            }
                            // Handle inline bullet points (•) within a paragraph - only if not already processed as a list line
                            else if (line.includes('•') && !line.match(/^[\*\-\•] /)) {
                                // Split by bullet points
                                const parts = line.split(/(?= • )/);
                                const textParts = [];
                                const bulletItems = [];
                                
                                parts.forEach(part => {
                                    if (part.trim().startsWith('•')) {
                                        let bulletText = part.replace(/^•\s+/, '').trim();
                                        // Remove any remaining bullet characters
                                        bulletText = bulletText.replace(/^[\*\-\•]\s+/, '').trim();
                                        if (bulletText) {
                                            bulletItems.push('<li>' + processInlineFormatting(escapeText(bulletText)) + '</li>');
                                        }
                                    } else {
                                        const text = part.trim();
                                        if (text) {
                                            textParts.push(processInlineFormatting(escapeText(text)));
                                        }
                                    }
                                });
                                
                                if (textParts.length > 0) {
                                    result.push('<p class="mb-2">' + textParts.join(' ') + '</p>');
                                }
                                if (bulletItems.length > 0) {
                                    result.push('<ul class="ml-6 my-2">' + bulletItems.join('') + '</ul>');
                                }
                            } else {
                                // Regular paragraph without bullets
                                if (result.length === 0 || result[result.length - 1].match(/<\/(p|h1|h2|h3|ul|pre)>$/)) {
                                    result.push('<p class="mb-2">' + paraContent);
                                } else {
                                    result[result.length - 1] += '<br>' + paraContent;
                                }
                            }
                        }
                    }
                    
                    // Close any open list
                    if (inList) {
                        const listTag = listIsOrdered ? '<ol class="ml-6 my-2">' : '<ul class="ml-6 my-2">';
                        const listCloseTag = listIsOrdered ? '</ol>' : '</ul>';
                        result.push(listTag + listItems.join('') + listCloseTag);
                    }
                    
                    // Close any open paragraph
                    if (result.length > 0 && !result[result.length - 1].match(/<\/(p|h1|h2|h3|ul|pre)>$/)) {
                        result[result.length - 1] += '</p>';
                    }
                    
                    return result.join('');
                }
            });
            
            let html = processedParts.join('');
            
            // If no HTML was generated, wrap in paragraph
            if (!html || html.trim() === '') {
                html = '<p class="mb-2">' + escapeText(text) + '</p>';
            }
            
            return html;
        }
        
        // Track if branch notes have been added
        let tedsBranchNoteAdded = false;
        let paigesBranchNoteAdded = false;
        let carlosBranchNoteAdded = false;
        let sylviasBranchNoteAdded = false;
        
        // Function to add Ted's branch note
        function addTedsBranchNote() {
            if (tedsBranchNoteAdded || currentBranch !== 'Ted S.') {
                return;
            }
            
            const messagesContainer = chatMessages.querySelector('.max-w-4xl');
            if (!messagesContainer) return;
            
            // Check if there are any branch messages already
            const existingBranchMessages = messagesContainer.querySelectorAll('.branch-message');
            if (existingBranchMessages.length > 0) {
                // Find the first branch message
                const firstBranchMessage = existingBranchMessages[0];
                
                // Create a wrapper div that will contain both the note and maintain positioning
                const wrapperDiv = document.createElement('div');
                wrapperDiv.className = 'relative';
                wrapperDiv.style.position = 'relative';
                
                // Create note element
                const noteDiv = document.createElement('div');
                noteDiv.className = 'branch-note ted-note';
                noteDiv.innerHTML = `
                    <strong>Note from Ted:</strong>
                    I'm focusing on the behavioral metrics approach, particularly operationalizing switching behavior and time ranges for meaningful differences between conditions.
                `;
                
                // Clone the first branch message and its siblings until we find a non-branch message or end
                const firstBranchMessageParent = firstBranchMessage.parentNode;
                const firstBranchMessageIndex = Array.from(firstBranchMessageParent.children).indexOf(firstBranchMessage);
                
                // Insert wrapper before the first branch message
                firstBranchMessageParent.insertBefore(wrapperDiv, firstBranchMessage);
                
                // Move the first branch message into the wrapper
                wrapperDiv.appendChild(firstBranchMessage);
                
                // Add the note to the wrapper
                wrapperDiv.appendChild(noteDiv);
                
                tedsBranchNoteAdded = true;
            }
        }
        
        // Function to add Paige's branch note
        function addPaigesBranchNote() {
            if (paigesBranchNoteAdded || currentBranch !== 'Paige T.') {
                return;
            }
            
            const messagesContainer = chatMessages.querySelector('.max-w-4xl');
            if (!messagesContainer) return;
            
            // Check if there are any branch messages already
            const existingBranchMessages = messagesContainer.querySelectorAll('.branch-message');
            if (existingBranchMessages.length > 0) {
                // Find the first branch message
                const firstBranchMessage = existingBranchMessages[0];
                
                // Create a wrapper div that will contain both the note and maintain positioning
                const wrapperDiv = document.createElement('div');
                wrapperDiv.className = 'relative';
                wrapperDiv.style.position = 'relative';
                
                // Create note element
                const noteDiv = document.createElement('div');
                noteDiv.className = 'branch-note paige-note';
                noteDiv.innerHTML = `
                    <strong>Note from Paige:</strong>
                    I'm interested in understanding the student experience through qualitative methods - exploring how students feel about different study methods and the reasons behind their choices.
                `;
                
                // Clone the first branch message and its siblings until we find a non-branch message or end
                const firstBranchMessageParent = firstBranchMessage.parentNode;
                const firstBranchMessageIndex = Array.from(firstBranchMessageParent.children).indexOf(firstBranchMessage);
                
                // Insert wrapper before the first branch message
                firstBranchMessageParent.insertBefore(wrapperDiv, firstBranchMessage);
                
                // Move the first branch message into the wrapper
                wrapperDiv.appendChild(firstBranchMessage);
                
                // Add the note to the wrapper
                wrapperDiv.appendChild(noteDiv);
                
                paigesBranchNoteAdded = true;
            }
        }
        
        // Function to add Carlos's branch note
        function addCarlosBranchNote() {
            if (carlosBranchNoteAdded || currentBranch !== 'Carlos R.') {
                return;
            }
            
            const messagesContainer = chatMessages.querySelector('.max-w-4xl');
            if (!messagesContainer) return;
            
            // In Carlos's branch, find the first message that's NOT a paige-message (Carlos's first contribution)
            const allBranchMessages = messagesContainer.querySelectorAll('.branch-message');
            let carlosFirstMessage = null;
            
            for (let msg of allBranchMessages) {
                if (!msg.classList.contains('paige-message')) {
                    carlosFirstMessage = msg;
                    break;
                }
            }
            
            // If no Carlos message found, use the first branch message
            if (!carlosFirstMessage && allBranchMessages.length > 0) {
                carlosFirstMessage = allBranchMessages[0];
            }
            
            if (carlosFirstMessage) {
                // Create a wrapper div that will contain both the note and maintain positioning
                const wrapperDiv = document.createElement('div');
                wrapperDiv.className = 'relative';
                wrapperDiv.style.position = 'relative';
                
                // Create note element
                const noteDiv = document.createElement('div');
                noteDiv.className = 'branch-note carlos-note';
                noteDiv.innerHTML = `
                    <strong>Note from Carlos:</strong>
                    I'm exploring the quantitative approach, focusing on experimental and quasi-experimental designs to test relationships and effects between study methods and outcomes.
                `;
                
                // Clone the first branch message and its siblings until we find a non-branch message or end
                const carlosFirstMessageParent = carlosFirstMessage.parentNode;
                
                // Insert wrapper before Carlos's first message
                carlosFirstMessageParent.insertBefore(wrapperDiv, carlosFirstMessage);
                
                // Move Carlos's first message into the wrapper
                wrapperDiv.appendChild(carlosFirstMessage);
                
                // Add the note to the wrapper
                wrapperDiv.appendChild(noteDiv);
                
                carlosBranchNoteAdded = true;
            }
        }
        
        // Function to add Sylvia's note (for main chat view)
        function addSylviasNote() {
            if (sylviasBranchNoteAdded || currentChatId !== 'sylvia-research-questions' || currentBranch !== null) {
                return;
            }
            
            const messagesContainer = chatMessages.querySelector('.max-w-4xl');
            if (!messagesContainer) return;
            
            // Find the first user message (Sylvia's initial message)
            const firstUserMessage = messagesContainer.querySelector('.flex.justify-end');
            if (firstUserMessage) {
                // Create a wrapper div
                const wrapperDiv = document.createElement('div');
                wrapperDiv.className = 'relative';
                wrapperDiv.style.position = 'relative';
                
                // Create note element
                const noteDiv = document.createElement('div');
                noteDiv.className = 'branch-note sylvia-note';
                noteDiv.innerHTML = `
                    <strong>Note from Sylvia:</strong>
                    I'm starting this conversation to explore research design options for studying student study habits. I'm open to different methodological approaches.
                `;
                
                const firstUserMessageParent = firstUserMessage.parentNode;
                
                // Insert wrapper before the first user message
                firstUserMessageParent.insertBefore(wrapperDiv, firstUserMessage);
                
                // Move the first user message into the wrapper
                wrapperDiv.appendChild(firstUserMessage);
                
                // Add the note to the wrapper
                wrapperDiv.appendChild(noteDiv);
                
                sylviasBranchNoteAdded = true;
            }
        }
        
        // Function to add message to chat
        function addMessageToChat(text, isUser = false, isBranchMessage = false) {
            const messageDiv = document.createElement('div');
            let className = isUser ? 'flex justify-end mb-6' : 'flex justify-start mb-6';
            
            // Add branch-message class if this is a message after the branch point
            if (isBranchMessage && isUser) {
                className += ' branch-message';
            }
            
            // Add message-selectable class for sharing functionality
            className += ' message-selectable';
            
            messageDiv.className = className;
            messageDiv.dataset.messageId = 'msg-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
            
            if (isUser) {
                messageDiv.innerHTML = `
                    <div class="max-w-[75%] bg-blue-50 rounded-[5px] px-5 py-4 shadow-md">
                        <p class="text-gray-800 leading-relaxed">${escapeHtml(text)}</p>
                    </div>
                `;
            } else {
                // Use markdown rendering for AI messages
                const formattedText = markdownToHtml(text);
                messageDiv.innerHTML = `
                    <div class="ai-message-bubble max-w-[75%] bg-white rounded-[5px] px-5 py-4 shadow-md">
                        <div class="text-gray-800 leading-relaxed prose prose-sm max-w-none">${formattedText}</div>
                    </div>
                `;
            }
            
            // Add click handler for message selection (only in share mode)
            messageDiv.addEventListener('click', (e) => {
                if (document.body.classList.contains('share-mode')) {
                    e.stopPropagation();
                    e.preventDefault();
                    toggleMessagePair(messageDiv);
                    updateSelectedMessages();
                }
            });
            
            const messagesContainer = chatMessages.querySelector('.max-w-4xl');
            if (messagesContainer) {
                messagesContainer.appendChild(messageDiv);
                
                // Check if we need to add branch notes
                if (isBranchMessage && isUser) {
                    // Use setTimeout to ensure DOM is updated
                    setTimeout(() => {
                        if (currentBranch === 'Ted S.') {
                            addTedsBranchNote();
                        } else if (currentBranch === 'Paige T.') {
                            addPaigesBranchNote();
                        } else if (currentBranch === 'Carlos R.') {
                            addCarlosBranchNote();
                        }
                    }, 0);
                }
            }
            
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            return messageDiv;
        }
        
        // Function to generate initial message for a branch (pre-populated for demo)
        function generateBranchInitialMessage(branchName, branchColor, branchData) {
            // Pre-written messages for smooth demo experience
            let branchMessage = '';
            let aiResponse = '';
            
            if (branchName === 'Carlos R.') {
                branchMessage = "I'm interested in seeing if certain study methods actually lead to better exam scores. What would be a good way to test that?";
                aiResponse = "Great question! To test whether study methods affect exam scores, you could:\n\n**Compare two groups**:\n- Group 1: Students who use flashcards\n- Group 2: Students who just read their notes\n- Then compare their exam scores\n\n**Track students over time**:\n- Ask students to report which study methods they use\n- See if students who use certain methods get higher scores\n- Look for patterns across multiple exams\n\n**Test different methods directly**:\n- Have some students study one way (like practice tests)\n- Have other students study another way (like re-reading)\n- Give everyone the same exam and compare scores\n\nThe key is making sure you're comparing similar students (same class, similar backgrounds) so the study method is what's different, not other factors. Which approach sounds most doable for your situation?";
            } else if (branchName === 'Paige T.') {
                branchMessage = "I'm really interested in understanding the student experience - like how they feel about different study methods and why they choose what they do. What kind of study would help me learn about that?";
                aiResponse = "That sounds like a perfect fit for a qualitative study! You could:\n\n**Interview students** to hear their stories about studying:\n- \"What does your study process look like when preparing for exams?\"\n- \"How do you decide which study method to use for different classes?\"\n- \"What makes a study session feel successful to you?\"\n\n**Observe students studying** to see what they actually do:\n- Watch how they organize their notes\n- See when they take breaks\n- Notice what helps them focus\n\n**Ask students to keep journals** about their study habits for a few weeks\n\nThese approaches help you understand the \"why\" and \"how\" behind study habits, not just the numbers. Would you like help planning interviews or observations?";
            } else if (branchName === 'Ted S.') {
                branchMessage = "The behavioral metrics approach sounds promising. I'm curious about the switching behavior metric specifically - how would you operationalize that in a study? Also, what's the typical time range you'd expect to see meaningful differences between conditions?";
                aiResponse = "For switching behavior, you can track: (1) **tab switches** between article and notes/document, (2) **scroll events** indicating re-reading, (3) **time spent** in each view before switching. Use event logging (e.g., browser extension or screen recording with timestamp analysis). \n\nTime ranges depend on task complexity, but for literature review: \n- **Short tasks** (15-30 min): differences may appear in first 5-10 minutes \n- **Medium tasks** (1-2 hours): meaningful differences typically emerge after 20-30 minutes \n- **Long tasks** (2+ hours): patterns stabilize around 45-60 minutes\n\nReference: **Pirolli & Card (1999)** on information foraging found switching patterns differentiate expert vs. novice behavior within first 20 minutes of task.";
            } else {
                // Generic message for other branches
                branchMessage = "I'd like to explore this further. Can you provide more details?";
                aiResponse = "I'd be happy to help you explore this topic further. What specific aspect would you like to dive deeper into?";
            }
            
            // Add the branch person's message to the conversation (this is a branch message)
            addMessageToChat(branchMessage, true, true);
            
            // Add to conversation history
            conversationHistory.push({
                role: 'user',
                content: branchMessage
            });
            
            // Add AI response immediately (no API call)
            addMessageToChat(aiResponse, false);
            
            // Add assistant message to conversation history
            conversationHistory.push({
                role: 'assistant',
                content: aiResponse
            });
            
            // Update branch data directly
            branchData.messages.push({
                role: 'user',
                content: branchMessage
            });
            branchData.messages.push({
                role: 'assistant',
                content: aiResponse
            });
            branchData.conversationHistory = JSON.parse(JSON.stringify(conversationHistory));
            branchData.initialized = true;
            
            // Save the chat - this will now correctly save only to this branch
            saveCurrentChat();
            
            // Scroll to bottom
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        // Function to add loading indicator
        function addLoadingIndicator() {
            const loadingDiv = document.createElement('div');
            loadingDiv.id = 'loadingIndicator';
            loadingDiv.className = 'flex justify-start mb-6';
            loadingDiv.innerHTML = `
                <div class="ai-message-bubble max-w-[75%] bg-white rounded-[5px] px-5 py-4 shadow-md">
                    <div class="flex items-center gap-2">
                        <div class="flex gap-1">
                            <div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 0s"></div>
                            <div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 0.2s"></div>
                            <div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 0.4s"></div>
                        </div>
                        <span class="text-gray-500 text-sm">Thinking...</span>
                    </div>
                </div>
            `;
            const messagesContainer = chatMessages.querySelector('.max-w-4xl');
            if (messagesContainer) {
                messagesContainer.appendChild(loadingDiv);
            }
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        // Function to remove loading indicator
        function removeLoadingIndicator() {
            const loadingIndicator = document.getElementById('loadingIndicator');
            if (loadingIndicator) {
                loadingIndicator.remove();
            }
        }
        
        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Function to update active state of branch person buttons
        function updateBranchPersonActiveState(activeBranchName) {
            document.querySelectorAll('.branch-person').forEach(person => {
                const personName = person.dataset.name;
                if (personName === activeBranchName) {
                    person.classList.add('active');
                } else {
                    person.classList.remove('active');
                }
            });
        }
        
        // Branch button functionality
        branchButton.addEventListener('click', (e) => {
            e.stopPropagation();
            branchDropdown.classList.toggle('show');
            // Close share dropdown if open
            shareDropdown.classList.remove('show');
            document.body.classList.remove('share-mode');
        });
        
        // Track selected messages for sharing
        let selectedMessages = new Set();
        
        // Function to get message pair (user + AI)
        function getMessagePair(messageDiv) {
            const isUser = messageDiv.classList.contains('justify-end');
            let userMsg = null;
            let aiMsg = null;
            
            // Get the messages container
            const messagesContainer = messageDiv.closest('.max-w-4xl');
            if (!messagesContainer) return { userMsg: null, aiMsg: null };
            
            // Get all message-selectable elements in order
            const allMessages = Array.from(messagesContainer.querySelectorAll('.message-selectable'));
            const currentIndex = allMessages.indexOf(messageDiv);
            
            if (currentIndex === -1) return { userMsg: null, aiMsg: null };
            
            if (isUser) {
                userMsg = messageDiv;
                // Find the immediately following AI message (next message-selectable that is justify-start)
                for (let i = currentIndex + 1; i < allMessages.length; i++) {
                    const nextMsg = allMessages[i];
                    if (nextMsg.classList.contains('justify-start')) {
                        aiMsg = nextMsg;
                        break;
                    }
                    // If we hit another user message, stop looking
                    if (nextMsg.classList.contains('justify-end')) {
                        break;
                    }
                }
            } else {
                aiMsg = messageDiv;
                // Find the immediately preceding user message (previous message-selectable that is justify-end)
                for (let i = currentIndex - 1; i >= 0; i--) {
                    const prevMsg = allMessages[i];
                    if (prevMsg.classList.contains('justify-end')) {
                        userMsg = prevMsg;
                        break;
                    }
                    // If we hit another AI message, stop looking
                    if (prevMsg.classList.contains('justify-start')) {
                        break;
                    }
                }
            }
            
            return { userMsg, aiMsg };
        }
        
        // Function to get all message pairs in order
        function getAllMessagePairs() {
            const messagesContainer = document.querySelector('.max-w-4xl');
            if (!messagesContainer) return [];
            
            const allMessages = Array.from(messagesContainer.querySelectorAll('.message-selectable'));
            const pairs = [];
            let i = 0;
            
            while (i < allMessages.length) {
                const msg = allMessages[i];
                if (msg.classList.contains('justify-end')) {
                    // This is a user message, find its AI reply
                    const { userMsg, aiMsg } = getMessagePair(msg);
                    if (userMsg && aiMsg) {
                        pairs.push({ userMsg, aiMsg, index: pairs.length });
                        // Skip to after the AI message
                        const aiIndex = allMessages.indexOf(aiMsg);
                        i = aiIndex + 1;
                    } else {
                        i++;
                    }
                } else {
                    i++;
                }
            }
            
            return pairs;
        }
        
        // Function to fill gaps between selected pairs
        function fillGapsBetweenSelectedPairs() {
            const allPairs = getAllMessagePairs();
            const selectedPairs = [];
            
            // Find all selected pairs
            allPairs.forEach((pair, index) => {
                if (pair.userMsg.classList.contains('selected') && pair.aiMsg.classList.contains('selected')) {
                    selectedPairs.push({ pair, index });
                }
            });
            
            if (selectedPairs.length < 2) return; // Need at least 2 pairs to have gaps
            
            // Sort by index
            selectedPairs.sort((a, b) => a.index - b.index);
            
            // Fill gaps between consecutive selected pairs
            for (let i = 0; i < selectedPairs.length - 1; i++) {
                const currentIndex = selectedPairs[i].index;
                const nextIndex = selectedPairs[i + 1].index;
                
                // If there are pairs between them, select those too
                for (let j = currentIndex + 1; j < nextIndex; j++) {
                    const gapPair = allPairs[j];
                    if (gapPair && !gapPair.userMsg.classList.contains('selected')) {
                        gapPair.userMsg.classList.add('selected');
                        gapPair.aiMsg.classList.add('selected');
                    }
                }
            }
        }
        
        // Function to check if a pair is in the middle of other selected pairs
        function isPairInMiddle(userMsg, aiMsg) {
            const allPairs = getAllMessagePairs();
            const currentPairIndex = allPairs.findIndex(pair => 
                pair.userMsg === userMsg && pair.aiMsg === aiMsg
            );
            
            if (currentPairIndex === -1) return false;
            
            // Check if there are selected pairs before and after this one
            let hasSelectedBefore = false;
            let hasSelectedAfter = false;
            
            for (let i = currentPairIndex - 1; i >= 0; i--) {
                const pair = allPairs[i];
                if (pair.userMsg.classList.contains('selected') && 
                    pair.aiMsg.classList.contains('selected')) {
                    hasSelectedBefore = true;
                    break;
                }
            }
            
            for (let i = currentPairIndex + 1; i < allPairs.length; i++) {
                const pair = allPairs[i];
                if (pair.userMsg.classList.contains('selected') && 
                    pair.aiMsg.classList.contains('selected')) {
                    hasSelectedAfter = true;
                    break;
                }
            }
            
            // If there are selected pairs on both sides, this is in the middle
            return hasSelectedBefore && hasSelectedAfter;
        }
        
        // Function to toggle message pair selection
        function toggleMessagePair(messageDiv) {
            const { userMsg, aiMsg } = getMessagePair(messageDiv);
            
            // Only allow selection if both parts of the pair exist
            if (!userMsg || !aiMsg) {
                return false; // Can't select incomplete pair
            }
            
            const isSelected = messageDiv.classList.contains('selected');
            
            if (isSelected) {
                // Check if this pair is in the middle of other selected pairs
                if (isPairInMiddle(userMsg, aiMsg)) {
                    // Don't allow deselection of middle pairs
                    return false;
                }
                
                // Deselect both
                userMsg.classList.remove('selected');
                aiMsg.classList.remove('selected');
            } else {
                // Select both
                userMsg.classList.add('selected');
                aiMsg.classList.add('selected');
                
                // Fill any gaps between selected pairs
                fillGapsBetweenSelectedPairs();
            }
            
            return true;
        }
        
        // Function to update selected messages set
        function updateSelectedMessages() {
            selectedMessages.clear();
            document.querySelectorAll('.message-selectable.selected').forEach(msg => {
                selectedMessages.add(msg);
            });
        }
        
        // Function to validate that all selected messages are in complete pairs with no gaps
        function validateSelectedPairs() {
            const selected = Array.from(selectedMessages);
            const checked = new Set();
            
            for (const msg of selected) {
                if (checked.has(msg)) continue;
                
                const { userMsg, aiMsg } = getMessagePair(msg);
                
                // Check if this is a complete pair
                if (!userMsg || !aiMsg) {
                    return false; // Incomplete pair found
                }
                
                // Check if both are selected
                if (!userMsg.classList.contains('selected') || !aiMsg.classList.contains('selected')) {
                    return false; // Pair is not fully selected
                }
                
                checked.add(userMsg);
                checked.add(aiMsg);
            }
            
            // Ensure all selected messages are accounted for
            if (checked.size !== selected.length) {
                return false;
            }
            
            // Check for gaps: all selected pairs should be consecutive
            const allPairs = getAllMessagePairs();
            const selectedPairIndices = [];
            
            allPairs.forEach((pair, index) => {
                if (pair.userMsg.classList.contains('selected') && pair.aiMsg.classList.contains('selected')) {
                    selectedPairIndices.push(index);
                }
            });
            
            if (selectedPairIndices.length === 0) return false;
            
            // Sort indices
            selectedPairIndices.sort((a, b) => a - b);
            
            // Check if there are any gaps
            for (let i = 0; i < selectedPairIndices.length - 1; i++) {
                if (selectedPairIndices[i + 1] - selectedPairIndices[i] > 1) {
                    return false; // Gap found
                }
            }
            
            return true;
        }
        
        // Function to get content from selected messages
        function getSelectedMessagesContent() {
            if (selectedMessages.size === 0) return '';
            
            const messages = [];
            const messageDivs = Array.from(selectedMessages).sort((a, b) => {
                // Sort by position in DOM
                return a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;
            });
            
            messageDivs.forEach(div => {
                const isUser = div.classList.contains('justify-end');
                let content = '';
                
                if (isUser) {
                    const messageText = div.querySelector('p');
                    if (messageText) {
                        content = messageText.textContent.trim();
                    }
                } else {
                    // For AI messages, get text from formatted content
                    const messageContent = div.querySelector('.prose') || 
                                          div.querySelector('.ai-message-bubble > div') ||
                                          div.querySelector('div > div') ||
                                          div.querySelector('p');
                    if (messageContent) {
                        content = messageContent.textContent.trim();
                    }
                }
                
                if (content) {
                    const prefix = isUser ? 'You: ' : 'AI: ';
                    messages.push(prefix + content);
                }
            });
            
            return messages.join('\n\n');
        }
        
        // Share button functionality
        shareButton.addEventListener('click', (e) => {
            e.stopPropagation();
            
            const isShowing = shareDropdown.classList.toggle('show');
            
            // Close branch dropdown if open
            branchDropdown.classList.remove('show');
            
            // Toggle zoom on chat messages and enable selection mode
            if (isShowing) {
                document.body.classList.add('share-mode');
                // Clear any previous selections
                document.querySelectorAll('.message-selectable.selected').forEach(msg => {
                    msg.classList.remove('selected');
                });
                selectedMessages.clear();
            } else {
                document.body.classList.remove('share-mode');
                // Clear selections when closing share mode
                document.querySelectorAll('.message-selectable.selected').forEach(msg => {
                    msg.classList.remove('selected');
                });
                selectedMessages.clear();
            }
        });
        
        // Handle clicking on a person in the branch dropdown
        document.querySelectorAll('.branch-person').forEach(person => {
            person.addEventListener('click', (e) => {
                e.stopPropagation();
                const name = person.dataset.name;
                const color = person.dataset.color;
                
                // Close branch dropdown
                branchDropdown.classList.remove('show');
                
                // Save current chat before switching
                if (currentChatId) {
                    saveCurrentChat();
                }
                
                // If clicking on the same branch person, switch back to main view
                if (currentBranch === name && currentChatId) {
                    const chat = getChat(currentChatId);
                    if (chat) {
                        // Switch back to main conversation
                        currentBranch = null;
                        branchPoint = null;
                        conversationHistory = chat.conversationHistory || [];
                        
                        // Clear and reload main conversation messages
                        const messagesContainer = chatMessages.querySelector('.max-w-4xl');
                        if (messagesContainer) {
                            messagesContainer.innerHTML = '';
                        }
                        
                        // Load main conversation messages
                        if (chat.messages && chat.messages.length > 0) {
                            chat.messages.forEach(msg => {
                                addMessageToChat(msg.content, msg.role === 'user', false);
                            });
                        }
                        
                        // Save chat with updated branch info
                        chat.currentBranch = null;
                        chat.branchPoint = null;
                        saveChat(currentChatId, chat);
                        
                        // Update UI - remove branch styling
                        document.body.classList.remove('carlos-selected', 'ted-selected', 'paige-selected', 'sylvia-chat');
                        // Re-add sylvia-chat if this is Sylvia's conversation
                        if (currentChatId === 'sylvia-research-questions') {
                            document.body.classList.add('sylvia-chat');
                        }
                        
                        // Update branch person active state (none active)
                        updateBranchPersonActiveState(null);
                        
                        // Scroll to bottom
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    }
                    return;
                }
                
                // If no current chat, create one first
                if (!currentChatId) {
                    currentChatId = 'chat-' + Date.now();
                    const newChat = {
                        title: 'New Chat',
                        messages: [],
                        conversationHistory: [],
                        branches: {},
                        currentBranch: null,
                        branchPoint: null
                    };
                    saveChat(currentChatId, newChat);
                }
                
                const chat = getChat(currentChatId);
                if (!chat) return;
                
                // Initialize branches if needed
                if (!chat.branches) {
                    chat.branches = {};
                }
                
                // Get current message count before branching (this is the branch point)
                const messagesContainer = chatMessages.querySelector('.max-w-4xl');
                const currentMessageCount = messagesContainer ? messagesContainer.querySelectorAll('.flex').length : 0;
                
                // Create or switch to branch
                if (!chat.branches[name]) {
                    // Create new branch - copy conversation up to this point
                    // Make a deep copy of the conversation history to ensure independence
                    const branchHistory = JSON.parse(JSON.stringify(conversationHistory));
                    const branchMessages = [];
                    
                    // Get messages from DOM up to this point
                    if (messagesContainer) {
                        const messageDivs = messagesContainer.querySelectorAll('.flex');
                        messageDivs.forEach(div => {
                            const messageText = div.querySelector('p');
                            if (messageText) {
                                const isUser = div.classList.contains('justify-end');
                                branchMessages.push({
                                    role: isUser ? 'user' : 'assistant',
                                    content: messageText.textContent
                                });
                            }
                        });
                    }
                    
                    // Create initial branch structure
                    chat.branches[name] = {
                        name: name,
                        color: color,
                        conversationHistory: branchHistory,
                        messages: JSON.parse(JSON.stringify(branchMessages)), // Deep copy
                        branchPoint: currentMessageCount,
                        initialized: false // Track if branch has been initialized with unique content
                    };
                    
                    // Save the branch structure first
                    saveChat(currentChatId, chat);
                }
                
                // Switch to this branch
                currentBranch = name;
                branchPoint = chat.branches[name].branchPoint;
                // Create a new array reference so modifications don't affect the stored version
                conversationHistory = JSON.parse(JSON.stringify(chat.branches[name].conversationHistory));
                
                // Clear and reload messages for this branch
                if (messagesContainer) {
                    messagesContainer.innerHTML = '';
                }
                
                // Load branch messages
                if (chat.branches[name].messages && chat.branches[name].messages.length > 0) {
                    const branchPointIndex = chat.branches[name].branchPoint || 0;
                    chat.branches[name].messages.forEach((msg, index) => {
                        // Only mark messages after the branch point as branch messages
                        const isBranchMsg = index >= branchPointIndex;
                        const messageDiv = addMessageToChat(msg.content, msg.role === 'user', isBranchMsg);
                        // In Ted's branch of Sylvia's chat, mark Carlos's message (index 2) with a special class for blue styling
                        if (messageDiv && name === 'Ted S.' && currentChatId === 'sylvia-research-questions' && 
                            index === 2 && msg.role === 'user' && isBranchMsg) {
                            messageDiv.classList.add('carlos-message');
                            // Force the blue color directly via inline style to ensure it overrides
                            const bubbleDiv = messageDiv.querySelector('div.bg-blue-50');
                            if (bubbleDiv) {
                                bubbleDiv.style.backgroundColor = '#90DFFB';
                            }
                        }
                    });
                }
                
                // If branch hasn't been initialized, generate unique content for this person
                if (!chat.branches[name].initialized) {
                    // Generate a unique message from this person's perspective
                    generateBranchInitialMessage(name, color, chat.branches[name]);
                }
                
                // Save chat with branch info
                chat.currentBranch = currentBranch;
                chat.branchPoint = branchPoint;
                saveChat(currentChatId, chat);
                
                // Update UI
                document.body.classList.remove('carlos-selected', 'ted-selected', 'paige-selected', 'sylvia-chat');
                // Keep sylvia-chat class if this is Sylvia's conversation
                if (currentChatId === 'sylvia-research-questions') {
                    document.body.classList.add('sylvia-chat');
                }
                if (name === 'Carlos R.') {
                    document.body.classList.add('carlos-selected');
                } else if (name === 'Ted S.') {
                    document.body.classList.add('ted-selected');
                } else if (name === 'Paige T.') {
                    document.body.classList.add('paige-selected');
                }
                
                // Update branch person active state
                updateBranchPersonActiveState(name);
                
                // Reset all branch note flags when switching branches
                tedsBranchNoteAdded = false;
                paigesBranchNoteAdded = false;
                carlosBranchNoteAdded = false;
                sylviasBranchNoteAdded = false;
                
                // Add branch notes if applicable
                if (name === 'Ted S.') {
                    setTimeout(() => {
                        addTedsBranchNote();
                    }, 100);
                } else if (name === 'Paige T.') {
                    setTimeout(() => {
                        addPaigesBranchNote();
                    }, 100);
                } else if (name === 'Carlos R.') {
                    setTimeout(() => {
                        addCarlosBranchNote();
                    }, 100);
                }
                
                // Scroll to bottom
                chatMessages.scrollTop = chatMessages.scrollHeight;
            });
        });
        
        // Function to get full chat content
        function getFullChatContent() {
            const messagesContainer = chatMessages.querySelector('.max-w-4xl');
            if (!messagesContainer) return '';
            
            const messages = [];
            const messageDivs = messagesContainer.querySelectorAll('.flex');
            
            messageDivs.forEach(div => {
                const isUser = div.classList.contains('justify-end');
                let content = '';
                
                if (isUser) {
                    const messageText = div.querySelector('p');
                    if (messageText) {
                        content = messageText.textContent.trim();
                    }
                } else {
                    // For AI messages, get text from formatted content
                    const messageContent = div.querySelector('.prose') || 
                                          div.querySelector('.ai-message-bubble > div') ||
                                          div.querySelector('div > div') ||
                                          div.querySelector('p');
                    if (messageContent) {
                        content = messageContent.textContent.trim();
                    }
                }
                
                if (content) {
                    const prefix = isUser ? 'You: ' : 'AI: ';
                    messages.push(prefix + content);
                }
            });
            
            return messages.join('\n\n');
        }
        
        // Function to update selected messages preview
        function updateSelectedMessagesPreview() {
            const previewDiv = document.getElementById('selectedMessagesPreview');
            const listDiv = document.getElementById('selectedMessagesList');
            
            if (selectedMessages.size > 0) {
                previewDiv.style.display = 'block';
                const messages = Array.from(selectedMessages).sort((a, b) => {
                    return a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;
                });
                
                listDiv.innerHTML = '';
                messages.forEach((msgDiv, index) => {
                    const isUser = msgDiv.classList.contains('justify-end');
                    let content = '';
                    
                    if (isUser) {
                        const messageText = msgDiv.querySelector('p');
                        if (messageText) {
                            content = messageText.textContent.trim();
                        }
                    } else {
                        const messageContent = msgDiv.querySelector('.prose') || 
                                              msgDiv.querySelector('.ai-message-bubble > div') ||
                                              msgDiv.querySelector('div > div') ||
                                              msgDiv.querySelector('p');
                        if (messageContent) {
                            content = messageContent.textContent.trim();
                        }
                    }
                    
                    if (content) {
                        const prefix = isUser ? 'You' : 'AI';
                        const preview = content.length > 50 ? content.substring(0, 50) + '...' : content;
                        const item = document.createElement('div');
                        item.className = 'text-xs mb-1';
                        item.textContent = `${prefix}: ${preview}`;
                        listDiv.appendChild(item);
                    }
                });
            } else {
                previewDiv.style.display = 'none';
            }
        }
        
        // Handle clicking on a person in the share dropdown
        document.querySelectorAll('.share-person').forEach(person => {
            person.addEventListener('click', (e) => {
                e.stopPropagation();
                const name = person.dataset.name;
                const initial = person.dataset.initial;
                const color = person.dataset.color;
                
                // Hide dropdown
                shareDropdown.classList.remove('show');
                
                // Check if any messages are selected
                updateSelectedMessages();
                
                if (selectedMessages.size === 0) {
                    // If no messages selected, show a message
                    alert('Please select one or more message pairs to share. Click on message bubbles to select them (user messages and their AI replies are selected together).');
                    return;
                }
                
                // Validate that all selected messages are in complete pairs
                updateSelectedMessages();
                if (!validateSelectedPairs()) {
                    alert('Please select complete message pairs (user input and AI reply together). You cannot share only a user message or only an AI message.');
                    return;
                }
                
                // Update tooltip with person's info
                tooltipAvatar.textContent = initial;
                if (color.startsWith('#')) {
                    tooltipAvatar.className = 'w-10 h-10 rounded-full flex items-center justify-center text-white font-semibold text-sm';
                    tooltipAvatar.style.backgroundColor = color;
                } else {
                    tooltipAvatar.className = `w-10 h-10 ${color} rounded-full flex items-center justify-center text-white font-semibold text-sm`;
                    tooltipAvatar.style.backgroundColor = '';
                }
                tooltipName.textContent = name;
                
                // Update preview of selected messages
                updateSelectedMessagesPreview();
                
                // Clear textarea for note
                tooltipTextarea.value = '';
                tooltipTextarea.placeholder = 'Add a note about what you\'re sharing...';
                
                // Reset footer to show Send button (remove sent state)
                shareTooltipFooter.classList.remove('sent');
                
                // Show tooltip and backdrop
                shareTooltip.classList.add('show');
                shareTooltipBackdrop.classList.add('show');
            });
        });
        
        // Close tooltip
        function closeShareTooltip() {
            shareTooltip.classList.remove('show');
            shareTooltipBackdrop.classList.remove('show');
            document.body.classList.remove('share-mode');
        }
        
        closeTooltip.addEventListener('click', closeShareTooltip);
        
        // Send tooltip message
        if (sendTooltip) {
            sendTooltip.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                // Get the note from textarea
                const note = tooltipTextarea ? tooltipTextarea.value.trim() : '';
                
                // Update and validate selected messages
                updateSelectedMessages();
                
                if (selectedMessages.size === 0) {
                    alert('Please select one or more message pairs to share. Click on message bubbles to select them (user messages and their AI replies are selected together).');
                    return;
                }
                
                // Validate that all selected messages are in complete pairs
                if (!validateSelectedPairs()) {
                    alert('Please select complete message pairs (user input and AI reply together). You cannot share only a user message or only an AI message.');
                    return;
                }
                
                // Get selected messages content
                const selectedContent = getSelectedMessagesContent();
                
                // Combine note and selected messages
                let fullMessage = '';
                if (note) {
                    fullMessage = note + '\n\n---\n\n' + selectedContent;
                } else {
                    fullMessage = selectedContent;
                }
                
                console.log('Send button clicked');
                console.log(`Sending to ${tooltipName ? tooltipName.textContent : 'unknown'}:`);
                console.log('Note:', note);
                console.log('Selected messages:', selectedContent);
                
                // Here you would send the message to the selected person
                // For now, we'll just show a notification
                
                // Close share tooltip immediately
                if (shareTooltip) shareTooltip.classList.remove('show');
                if (shareTooltipBackdrop) shareTooltipBackdrop.classList.remove('show');
                document.body.classList.remove('share-mode');
                
                // Clear selections
                document.querySelectorAll('.message-selectable.selected').forEach(msg => {
                    msg.classList.remove('selected');
                });
                selectedMessages.clear();
                
                // Show notification toast
                if (notificationToast) {
                    notificationToast.classList.add('show');
                    
                    // Hide notification after 3 seconds
                    setTimeout(() => {
                        notificationToast.classList.remove('show');
                    }, 3000);
                }
            });
        } else {
            console.error('Send button not found!');
        }
        
        // Close sent message tooltip
        closeSentMessage.addEventListener('click', () => {
            sentMessageTooltip.classList.remove('show');
            shareTooltipBackdrop.classList.remove('show');
            document.body.classList.remove('share-mode');
        });
        
        // Close sent message when clicking backdrop
        shareTooltipBackdrop.addEventListener('click', (e) => {
            if (sentMessageTooltip.classList.contains('show')) {
                sentMessageTooltip.classList.remove('show');
                shareTooltipBackdrop.classList.remove('show');
                document.body.classList.remove('share-mode');
            } else if (shareTooltip.classList.contains('show')) {
                closeShareTooltip();
            }
        });
        
        // Close dropdowns when clicking outside
        document.addEventListener('click', (e) => {
            if (!branchButton.contains(e.target) && !branchDropdown.contains(e.target)) {
                branchDropdown.classList.remove('show');
            }
            if (!shareButton.contains(e.target) && !shareDropdown.contains(e.target) && !shareTooltip.contains(e.target) && !sentMessageTooltip.contains(e.target)) {
                shareDropdown.classList.remove('show');
                if (!shareTooltip.classList.contains('show') && !sentMessageTooltip.classList.contains('show')) {
                    document.body.classList.remove('share-mode');
                }
            }
        });
        
        chatForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const message = messageInput.value.trim();
            
            if (!message) return;
            
            // Create a new chat if we don't have one
            if (!currentChatId) {
                currentChatId = 'chat-' + Date.now();
                const newChat = {
                    title: message.substring(0, 50) + (message.length > 50 ? '...' : ''),
                    messages: [],
                    conversationHistory: [],
                    branches: {},
                    currentBranch: null,
                    branchPoint: null
                };
                saveChat(currentChatId, newChat);
                renderChatHistory();
            }
            
            // Disable input while processing
            messageInput.disabled = true;
            
            // Add user message to chat - check if we're in a branch and if this is after branch point
            const messagesContainer = chatMessages.querySelector('.max-w-4xl');
            const currentMessageCount = messagesContainer ? messagesContainer.querySelectorAll('.flex').length : 0;
            const isBranchMsg = currentBranch && branchPoint !== null && currentMessageCount >= branchPoint;
            addMessageToChat(message, true, isBranchMsg);
            
            // Add user message to conversation history
            conversationHistory.push({
                role: 'user',
                content: message
            });
            
            // Clear input
            messageInput.value = '';
            
            // Show loading indicator
            addLoadingIndicator();
            
            try {
                // Prepare conversation history for API
                // Send the conversation history up to (but not including) the current user message
                // This ensures each branch gets different responses based on their unique history
                const historyForAPI = conversationHistory.slice(0, -1);
                
                // Call API endpoint
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        message: message,
                        conversationHistory: historyForAPI
                    })
                });
                
                // Remove loading indicator
                removeLoadingIndicator();
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Failed to get response');
                }
                
                const data = await response.json();
                
                // Add assistant message to conversation history
                conversationHistory.push({
                    role: 'assistant',
                    content: data.message
                });
                
                // Add AI response to chat
                addMessageToChat(data.message, false);
                
                // Save the chat after adding messages
                saveCurrentChat();
                
                // Update chat history list
                renderChatHistory();
                
            } catch (error) {
                // Remove loading indicator
                removeLoadingIndicator();
                
                // Show error message
                const errorDiv = document.createElement('div');
                errorDiv.className = 'flex justify-start mb-6';
                errorDiv.innerHTML = `
                    <div class="ai-message-bubble max-w-[85%] bg-red-50 border border-red-200 rounded-[5px] px-4 py-3">
                        <p class="text-red-800">Error: ${escapeHtml(error.message)}</p>
                    </div>
                `;
                const messagesContainer = chatMessages.querySelector('.max-w-4xl');
                if (messagesContainer) {
                    messagesContainer.appendChild(errorDiv);
                }
                chatMessages.scrollTop = chatMessages.scrollHeight;
                
                console.error('Error calling API:', error);
            } finally {
                // Re-enable input
                messageInput.disabled = false;
                messageInput.focus();
            }
        });
        
        // Allow Enter key to send (Shift+Enter for new line)
        messageInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                chatForm.dispatchEvent(new Event('submit'));
            }
        });
    </script>
</body>
</html>

